"{'model': 'gemma2:27b', 'response': '\"{ \\\\\"title\\\\\": \\\\\"Hard - Circular Queue with Limited Capacity\\\\\", \\\\\"description\\\\\": \\\\\"Design and implement a circular queue data structure with a fixed capacity. The queue should support the following operations:\\\\\\\\n\\\\\\\\n* `enqueue(data)`: Adds an element to the rear of the queue if there is space available. Returns `True` if successful, `False` otherwise.\\\\\\\\n* `dequeue()`: Removes and returns the element at the front of the queue if it\\'s not empty. Returns `None` if the queue is empty.\\\\\\\\n* `peek()`: Returns the element at the front of the queue without removing it. Returns `None` if the queue is empty.\\\\\\\\n* `is_full()`: Returns `True` if the queue is full, `False` otherwise.\\\\\\\\n* `is_empty()`: Returns `True` if the queue is empty, `False` otherwise.\\\\\\\\n\\\\\\\\n#### Function Signature\\\\\\\\n```python\\\\\\\\nclass CircularQueue:\\\\\\\\n    def __init__(self, capacity: int):\\\\\\\\n        pass\\\\\\\\n\\\\\\\\n    def enqueue(self, data) -> bool:\\\\\\\\n        pass\\\\\\\\n\\\\\\\\n    def dequeue(self) -> any:\\\\\\\\n        pass\\\\\\\\n\\\\\\\\n    def peek(self) -> any:\\\\\\\\n        pass\\\\\\\\n\\\\\\\\n    def is_full(self) -> bool:\\\\\\\\n        pass\\\\\\\\n\\\\\\\\n    def is_empty(self) -> bool:\\\\\\\\n        pass\\\\\\\\n```\\\\\\\\n\\\\\\\\n\\\\\", \\\\\"code\\\\\": \\\\\"class CircularQueue:\\\\\\\\n    def __init__(self, capacity: int):\\\\\\\\n        self.capacity = capacity\\\\\\\\n        self.queue = [None] * capacity\\\\\\\\n        self.front = 0\\\\\\\\n        self.rear = -1\\\\\\\\n\\\\\\\\n    def enqueue(self, data) -> bool:\\\\\\\\n        if self.is_full():\\\\\\\\n            return False\\\\\\\\n        self.rear = (self.rear + 1) % self.capacity\\\\\\\\n        self.queue[self.rear] = data\\\\\\\\n        return True\\\\\\\\n\\\\\\\\n    def dequeue(self) -> any:\\\\\\\\n        if self.is_empty():\\\\\\\\n            return None\\\\\\\\n        data = self.queue[self.front]\\\\\\\\n        self.front = (self.front + 1) % self.capacity\\\\\\\\n        return data\\\\\\\\n\\\\\\\\n    def peek(self) -> any:\\\\\\\\n        if self.is_empty():\\\\\\\\n            return None\\\\\\\\n        return self.queue[self.front]\\\\\\\\n\\\\\\\\n    def is_full(self) -> bool:\\\\\\\\n        return (self.rear + 1) % self.capacity == self.front\\\\\\\\n\\\\\\\\n    def is_empty(self) -> bool:\\\\\\\\n        return self.front == self.rear + 1\\\\\\\\n\\\\\", \\\\\"tests\\\\\": [\\\\\"q = CircularQueue(5)\\\\\\\\nassert q.enqueue(1) == True\\\\\\\\nassert q.enqueue(2) == True\\\\\\\\nassert q.enqueue(3) == True\\\\\\\\nassert q.dequeue() == 1\\\\\\\\nassert q.peek() == 2\\\\\", \\\\\"q = CircularQueue(3)\\\\\\\\nassert q.enqueue(\\'a\\') == True\\\\\\\\nassert q.enqueue(\\'b\\') == True\\\\\\\\nassert q.enqueue(\\'c\\') == True\\\\\\\\nassert q.enqueue(\\'d\\') == False\\\\\\\\nassert q.dequeue() == \\'a\\'\\\\\\\\nassert q.dequeue() == \\'b\\'\\\\\\\\nassert q.enqueue(\\'d\\') == True\\\\\\\\nassert q.dequeue() == \\'c\\'\\\\\\\\nassert q.dequeue() == \\'d\\'\\\\\", \\\\\"q = CircularQueue(2)\\\\\\\\nq.enqueue(10)\\\\\\\\nq.enqueue(20)\\\\\\\\nassert q.dequeue() == 10\\\\\\\\nassert q.peek() == 20\\\\\\\\nq.enqueue(30)\\\\\\\\nassert q.dequeue() == 20\\\\\\\\nassert q.dequeue() == 30\\\\\"] }\"'}"