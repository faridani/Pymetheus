"{'model': 'gemma2:27b', 'response': '\"{ \\\\\"title\\\\\": \\\\\"Hard -  Optimal Pathfinding in a Grid with Dynamic Obstacles\\\\\", \\\\\"description\\\\\": \\\\\"You are given a 2D grid representing a map. The grid contains empty cells (represented by \\'.\\') and obstacles (represented by \\'#\\'). You start at a designated cell \\'S\\' and need to reach a destination cell \\'D\\'.\\\\\\\\n\\\\\\\\nThere are dynamic obstacles that move according to a set of predefined rules. These rules are provided as a list of tuples, each containing the coordinates of an obstacle and its movement direction (\\'up\\', \\'down\\', \\'left\\', \\'right\\').\\\\\\\\n\\\\\\\\n#### Function Signature\\\\\\\\n\\\\\\\\n```python\\\\\\\\ndef find_optimal_path(grid: list[list[str]], start: tuple[int, int], destination: tuple[int, int], obstacle_rules: list[tuple[tuple[int, int], str]]) -> list[tuple[int, int]]: \\\\\\\\n```\\\\\\\\n\\\\\\\\n#### Input\\\\\\\\n\\\\\\\\n- `grid`: A 2D list representing the map. Each element is either \\'.\\', \\'#\\', \\'S\\', or \\'D\\'.\\\\\\\\n\\\\\\\\n- `start`: A tuple (row, column) representing the starting cell coordinates.\\\\\\\\n\\\\\\\\n- `destination`:  A tuple (row, column) representing the destination cell coordinates.\\\\\\\\n- `obstacle_rules`: A list of tuples. Each inner tuple contains: \\\\\\\\n    - Coordinates (row, column) of an obstacle.\\\\\\\\n    - Movement direction (\\'up\\', \\'down\\', \\'left\\', \\'right\\').\\\\\\\\n\\\\\\\\n#### Output\\\\\\\\n\\\\\\\\n- Returns a list of tuples representing the optimal path from the start to the destination.  Each tuple is in the format (row, column). If no path exists, return an empty list.\\\\\\\\n\\\\\\\\n#### Constraints\\\\\\\\n\\\\\\\\n - The grid will be rectangular and have dimensions between 1x1 and 20x20.\\\\\\\\n - There will be exactly one \\'S\\' cell and one \\'D\\' cell.\\\\\\\\n\\\\\\\\n#### Hints\\\\\\\\n\\\\\\\\n- Consider using a search algorithm like A* to find the shortest path.\\\\\\\\n- You need to account for the movement of dynamic obstacles when calculating the cost of moving between cells.\\\\\", \\\\\"code\\\\\": \\\\\"import heapq\\\\\\\\n\\\\\\\\ndef find_optimal_path(grid: list[list[str]], start: tuple[int, int], destination: tuple[int, int], obstacle_rules: list[tuple[tuple[int, int], str]]) -> list[tuple[int, int]]:\\\\\\\\n    rows = len(grid)\\\\\\\\n    cols = len(grid[0])\\\\\\\\n\\\\\\\\n    def is_valid_move(row, col):\\\\\\\\n        return 0 <= row < rows and 0 <= col < cols and grid[row][col] != \\'#\\'\\\\\\\\n\\\\\\\\n    def get_neighbors(row, col):\\\\\\\\n        neighbors = [(row - 1, col), (row + 1, col), (row, col - 1), (row, col + 1)]\\\\\\\\n        return [(r, c) for r, c in neighbors if is_valid_move(r, c)]\\\\\\\\n\\\\\\\\n    def manhattan_distance(pos1, pos2):\\\\\\\\n        return abs(pos1[0] - pos2[0]) + abs(pos1[1] - pos2[1])\\\\\\\\n\\\\\\\\n    open_list = [(manhattan_distance(start, destination), 0, start)]  # (f_score, g_score, position)\\\\\\\\n    came_from = {}\\\\\\\\n    cost_so_far = {}\\\\\\\\n\\\\\\\\n    for r in range(rows):\\\\\\\\n        for c in range(cols):\\\\\\\\n            if grid[r][c] != \\'#\\'\\\\\\\\n                cost_so_far[(r, c)] = float(\\'inf\\')\\\\\\\\n\\\\\\\\n    came_from[start] = None\\\\\\\\n    cost_so_far[start] = 0\\\\\\\\n\\\\\\\\n    while open_list:\\\\\\\\n        _, _, current = heapq.heappop(open_list)\\\\\\\\n\\\\\\\\n        if current == destination:\\\\\\\\n            path = [current]\\\\\\\\n            while came_from[current] is not None:\\\\\\\\n                current = came_from[current]\\\\\\\\n                path.append(current)\\\\\\\\n            return path[::-1]\\\\\\\\n\\\\\\\\n        for neighbor in get_neighbors(*current):\\\\\\\\n            new_cost = cost_so_far[current] + 1\\\\\\\\n            if new_cost < cost_so_far[neighbor]:\\\\\\\\n                cost_so_far[neighbor] = new_cost\\\\\\\\n                priority = new_cost + manhattan_distance(neighbor, destination)\\\\\\\\n                heapq.heappush(open_list, (priority, new_cost, neighbor))\\\\\\\\n                came_from[neighbor] = current\\\\\\\\n\\\\\\\\n    return [] # No path found\\\\\", \\\\\"tests\\\\\": [\\\\\"grid = [[\\'S\\', \\'.\\', \\'.\\'], [\\'.\\', \\'D\\', \\'#\\'], [\\'.\\', \\'.\\', \\'.\\']]; start = (0, 0); destination = (1, 1); obstacle_rules = []; assert find_optimal_path(grid, start, destination, obstacle_rules) == [(0, 0), (1, 0), (1, 1)]\\\\\", \\\\\"grid = [[\\'S\\', \\'.\\', \\'#\\'], [\\'.\\', \\'D\\', \\'.\\'], [\\'.\\', \\'#\\', \\'.\\']]; start = (0, 0); destination = (1, 1); obstacle_rules = [( (2, 1), \\'left\\') ]; assert find_optimal_path(grid, start, destination, obstacle_rules) == [(0, 0), (0, 1), (1, 1)]\\\\\", \\\\\"grid = [[\\'S\\', \\'.\\', \\'#\\'], [\\'.\\', \\'#\\', \\'D\\'], [\\'.\\', \\'.\\', \\'.\\']]; start = (0, 0); destination = (1, 2); obstacle_rules = []; assert find_optimal_path(grid, start, destination, obstacle_rules) == []\\\\\"] }\"'}"