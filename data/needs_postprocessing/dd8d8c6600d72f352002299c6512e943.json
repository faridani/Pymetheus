{
    "model": "llama3:latest",
    "response": "\"{ \\\"title\\\": \\\"Elegant Rectangle Packing\\\", \\\"description\\\": \\\"Given a list of rectangles with integer coordinates and dimensions, pack them into the smallest possible rectangle without overlapping. Each rectangle has its own unique ID and its bottom left corner is aligned to the top left corner of the previous rectangle (or the origin for the first one). The goal is to minimize the width and height of the resulting packed rectangle.\\\\n\\\\n#### Function Signature\\\\n```python\\\\ndef pack_rectangles(rectangles: list[tuple[int, int, int, int]]) -> tuple[int, int]:\\\\n```\\\\n\\\\n#### Input\\\\n- `rectangles` (list[tuple[int, int, int, int]]): A list of rectangles, where each rectangle is represented by a tuple of four integers `(x1, y1, x2, y2)` describing its top-left and bottom-right corners.\\\\n\\\\n#### Output\\\\n- Returns the width and height of the packed rectangle as a tuple `(width, height)`. If it's not possible to pack all rectangles without overlapping, returns `(-1, -1)`.\\\\n\\\", \\\"code\\\": \\\"from typing import List, Tuple\\\\n\\\\ndef pack_rectangles(rectangles: List[Tuple[int, int, int, int]]) -> Tuple[int, int]:\\\\n    if not rectangles:\\\\n        return 0, 0\\\\n\\\\n    packed_width = max(x2 for x1, _, x2, _ in rectangles)\\\\n    packed_height = 0\\\\n    prev_y2 = 0\\\\n    for x1, y1, x2, y2 in sorted(rectangles):\\\\n        if y1 > prev_y2:\\\\n            packed_height += y1 - prev_y2\\\\n        elif y1 < prev_y2:\\\\n            packed_width += prev_y2 - y1\\\\n        prev_y2 = y2\\\\n\\\\n    return packed_width + 1, packed_height + 1 if packed_height else 0\\\", \\\"tests\\\": [\\\"assert pack_rectangles([(1, 1, 3, 4), (5, 5, 7, 6)]) == (9, 8)\\\", \\\"assert pack_rectangles([(1, 1, 2, 3), (2, 2, 4, 4), (3, 3, 5, 5)]) == (10, 12)\\\", \\\"assert pack_rectangles([]) == (0, 0)\\\", \\\"assert pack_rectangles([(1, 1, 1, 1)]) == (2, 2)\\\"] }\""
}