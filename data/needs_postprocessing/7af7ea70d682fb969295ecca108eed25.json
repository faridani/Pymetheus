"{'model': 'gemma2:27b', 'response': '\"{ \\\\\"title\\\\\": \\\\\"Hard - Optimal Maze Pathfinding\\\\\", \\\\\"description\\\\\": \\\\\"You are given a 2D grid representing a maze. The grid contains the following characters:\\\\\\\\n\\\\\\\\n- `\\'S\\'` represents the starting cell.\\\\\\\\n- `\\'E\\'` represents the ending cell.\\\\\\\\n- `\\'.\\'` represents an empty cell that can be traversed.\\\\\\\\n- `\\'#\\'` represents a wall that cannot be traversed.\\\\\\\\n\\\\\\\\nWrite a function `find_optimal_path` that takes the maze grid as input and returns a list of coordinates representing the shortest path from the starting cell to the ending cell. If there is no path, return an empty list.\\\\\\\\n\\\\\\\\n#### Function Signature\\\\\\\\n```python\\\\\\\\ndef find_optimal_path(maze: list[list[str]]) -> list[tuple[int, int]]:\\\\\\\\n```\\\\\\\\n\\\\\\\\n#### Input\\\\\\\\n- `maze` (list[list[str]]): A 2D list representing the maze.\\\\\\\\n\\\\\\\\n#### Output\\\\\\\\n- Returns a list of tuples, where each tuple represents the (row, column) coordinates of a cell in the shortest path from \\'S\\' to \\'E\\'. If no path exists, return an empty list.\\\\\", \\\\\"code\\\\\": \\\\\"from collections import deque\\\\\\\\n\\\\\\\\ndef find_optimal_path(maze: list[list[str]]) -> list[tuple[int, int]]:\\\\\\\\n    rows = len(maze)\\\\\\\\n    cols = len(maze[0])\\\\\\\\n    start = None\\\\\\\\n    end = None\\\\\\\\n\\\\\\\\n    for i in range(rows):\\\\\\\\n        for j in range(cols):\\\\\\\\n            if maze[i][j] == \\'S\\':\\\\\\\\n                start = (i, j)\\\\\\\\n            elif maze[i][j] == \\'E\\':\\\\\\\\n                end = (i, j)\\\\\\\\n    if start is None or end is None:\\\\\\\\n        return [] # No start or end found\\\\\\\\n\\\\\\\\n    queue = deque([(start, [])])  # Queue to store (cell, path) tuples\\\\\\\\n    visited = set([start])\\\\\\\\n\\\\\\\\n    while queue:\\\\\\\\n        (row, col), path = queue.popleft()\\\\\\\\n\\\\\\\\n        if (row, col) == end:\\\\\\\\n            return path + [(row, col)] # Path found!\\\\\\\\n\\\\\\\\n        for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]:  # Explore neighbors\\\\\\\\n            new_row = row + dr\\\\\\\\n            new_col = col + dc\\\\\\\\n            if 0 <= new_row < rows and 0 <= new_col < cols and maze[new_row][new_col] != \\'#\\' and (new_row, new_col) not in visited:\\\\\\\\n                visited.add((new_row, new_col))\\\\\\\\n                queue.append(((new_row, new_col), path + [(row, col)]))\\\\\\\\n\\\\\\\\n    return [] # No path found\\\\\", \\\\\"tests\\\\\": [\\\\\"maze1 = [[\\'S\\',\\'.\\',\\'.\\'],[\\'.\\',\\'.\\',\\'E\\'],[\\'#\\',\\'#\\',\\'.\\']]\\\\\\\\ntest1 = find_optimal_path(maze1)\\\\\\\\nassert test1 == [(0, 0), (0, 1), (1, 1)] \\\\\", \\\\\"maze2 = [[\\'S\\',\\'.\\',\\'#\\'],[\\'.\\',\\'.\\',\\'E\\'],[\\'.\\',\\'#\\',\\'.\\']]\\\\\\\\ntest2 = find_optimal_path(maze2)\\\\\\\\nassert test2 == [(0, 0), (1, 0), (1, 1)]\\\\\"] }\"'}"