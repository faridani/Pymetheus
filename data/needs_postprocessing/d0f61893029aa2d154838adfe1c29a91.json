"{'model': 'gemma2:27b', 'response': '\"{ \\\\\"title\\\\\": \\\\\"Hard: Labyrinth Pathfinding\\\\\", \\\\\"description\\\\\": \\\\\"You are given a 2D grid representing a labyrinth. The grid contains the following characters:\\\\\\\\n\\\\\\\\n- `\\'S\\'` : Starting position\\\\\\\\n- `\\'E\\'` : Ending position\\\\\\\\n- `\\'.\\'` : Empty cell, can be traversed\\\\\\\\n- `\\'#\\'` : Wall, cannot be traversed\\\\\\\\n\\\\\\\\nWrite a function `find_path(grid)` that takes the labyrinth grid as input and returns a list of coordinates representing the shortest path from the starting point `\\'S\\'` to the ending point `\\'E\\'`. If no path exists, return an empty list.\\\\\\\\n\\\\\\\\n#### Function Signature\\\\\\\\n```python\\\\\\\\ndef find_path(grid: list[list[str]]) -> list[tuple[int, int]]:\\\\\\\\n```\\\\\\\\n\\\\\\\\n#### Input\\\\\\\\n- `grid` (list[list[str]]): A 2D grid representing the labyrinth.\\\\\\\\n\\\\\\\\n#### Output\\\\\\\\n- Returns a list of tuples, where each tuple represents the (row, column) coordinates of a cell on the shortest path from \\'S\\' to \\'E\\'. The list should be in order from start to end. If no path exists, return an empty list.\\\\\", \\\\\"code\\\\\": \\\\\"from collections import deque\\\\\\\\n\\\\\\\\ndef find_path(grid: list[list[str]]) -> list[tuple[int, int]]:\\\\\\\\n    rows = len(grid)\\\\\\\\n    cols = len(grid[0])\\\\\\\\n    start = None\\\\\\\\n    end = None\\\\\\\\n\\\\\\\\n    # Find start and end positions\\\\\\\\n    for row in range(rows):\\\\\\\\n        for col in range(cols):\\\\\\\\n            if grid[row][col] == \\'S\\':\\\\\\\\n                start = (row, col)\\\\\\\\n            elif grid[row][col] == \\'E\\':\\\\\\\\n                end = (row, col)\\\\\\\\n\\\\\\\\n    if start is None or end is None:\\\\\\\\n        return [] # No valid start or end\\\\\\\\n\\\\\\\\n    # Initialize queue for BFS with starting position and path\\\\\\\\n    queue = deque([(start, [start])])\\\\\\\\n    visited = set([start])\\\\\\\\n\\\\\\\\n    while queue:\\\\\\\\n        (row, col), path = queue.popleft()\\\\\\\\n        if (row, col) == end:\\\\\\\\n            return path\\\\\\\\n\\\\\\\\n        # Explore adjacent cells\\\\\\\\n        for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\\\\\\\\n            new_row = row + dr\\\\\\\\n            new_col = col + dc\\\\\\\\n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] != \\'#\\' and (new_row, new_col) not in visited:\\\\\\\\n                queue.append(((new_row, new_col), path + [(new_row, new_col)]))\\\\\\\\n                visited.add((new_row, new_col))\\\\\\\\n\\\\\\\\n    return [] # No path found\\\\\", \\\\\"tests\\\\\": [\\\\\"grid = [[\\'S\\',\\'.\\',\\'.\\'],\\\\\\\\n          [\\'.\\', \\'#\\', \\'.\\'],\\\\\\\\n          [\\'E\\',\\'.\\',\\'.\\']]\\\\\\\\nassert find_path(grid) == [(0, 0), (1, 0), (2, 0)] \\\\\", \\\\\"grid = [[\\'S\\',\\'.\\',\\'.\\'],\\\\\\\\n          [\\'.\\',\\'#\\',\\'.\\'],\\\\\\\\n          [\\'.\\',\\'.\\',\\'E\\']]\\\\\\\\nassert find_path(grid) == [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)] \\\\\", \\\\\"grid = [[\\'S\\',\\'.\\',\\'#\\'],\\\\\\\\n          [\\'#\\',\\'.\\',\\'.\\'],\\\\\\\\n          [\\'E\\',\\'.\\',\\'#\\']]\\\\\\\\nassert find_path(grid) == []\\\\\"] }\"'}"