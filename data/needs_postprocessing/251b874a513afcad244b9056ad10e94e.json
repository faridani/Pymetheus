{
    "model": "llama3:latest",
    "response": "\"{ \\\"title\\\": \\\"Hard: Finding the Shortest Path in a Maze\\\", \\\"description\\\": \\\"Imagine you have a maze that can be represented as a 2D list of characters, where '#' represents a wall and ' ' (space) represents an open path. You are standing at the top left corner of the maze and your goal is to reach the bottom right corner. Write a function `shortest_path` that finds the shortest possible path from the top left corner to the bottom right corner.\\\\n\\\\n#### Function Signature\\\\n```python\\\\ndef shortest_path(maze: list[list[str]]) -> str:\\\\n```\\\\n\\\\n#### Input\\\\n- `maze` (list[list[str]]): A 2D list of characters representing the maze, where '#' represents a wall and ' ' (space) represents an open path.\\\\n\\\\n#### Output\\\\n- Returns a string representing the shortest possible path from the top left corner to the bottom right corner. The path should be given as a sequence of directions ('U', 'D', 'L', 'R') indicating which direction to move in each step.\\\\n\\\", \\\"code\\\": \\\"from collections import deque\\\\n\\\\ndef shortest_path(maze: list[list[str]]) -> str:\\\\n    if maze[0][0] == '#' or maze[-1][-1] == '#':\\\\n        return ''  # Return an empty string if the start or end point is a wall\\\\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # Directions to move in the maze\\\\n    queue = deque([(0, 0, '')])  # Initialize the queue with the starting position and an empty path\\\\n    visited = {(0, 0)}  # Keep track of visited cells\\\\n    while queue:\\\\n        x, y, path = queue.popleft()\\\\n        if x == len(maze) - 1 and y == len(maze[0]) - 1:  # If the end point is reached, return the path\\\\n            return path\\\\n        for dx, dy in directions:\\\\n            nx, ny = x + dx, y + dy\\\\n            if (0 <= nx < len(maze)) and (0 <= ny < len(maze[0])) and maze[nx][ny] == ' ':\\\\n                if (nx, ny) not in visited:\\\\n                    queue.append((nx, ny, path + ('U' if dx > 0 else 'D' if dx < 0 else 'L' if dy > 0 else 'R')))\\\\n                    visited.add((nx, ny))\\\\n    return ''  # Return an empty string if no path is found\\\\n\\\", \\\"tests\\\": [\\\"assert shortest_path([['#', '#', '#'], ['#', ' ', '#'], ['#', ' ', '#']]) == '',\\\\n          assert shortest_path([[' ', ' ', ' ', '#'], [' ', ' ', ' ', '#'], [' ', ' ', ' ', '#'], [' ', ' ', ' ', '#']]) == '',\\\\n          assert shortest_path([[' ', ' ', ' ', '#'], [' ', ' ', ' ', '#'], [' ', ' ', ' ', '#'], ['#', ' ', ' ', ' ']]) == 'UDLL',\\\\n          assert shortest_path([['#', '#', '#'], ['#', ' ', '#'], ['#', ' ', '#']]) == '',\\\\n          assert shortest_path([[#, #, #], [#, ' ', #], [#, ' ', #]]) == ''\\\"] }\""
}