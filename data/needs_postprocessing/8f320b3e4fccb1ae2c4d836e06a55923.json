{
    "model": "llama3:latest",
    "response": "\"{ \\\"title\\\": \\\"Minimum Spanning Tree in a Graph\\\", \\\"description\\\": \\\"Given an undirected graph represented as an adjacency list, write a function to find the minimum spanning tree of the graph.\\\\n\\\\n#### Function Signature\\\\n```python\\\\ndef mst(graph: dict) -> list:\\\\n```\\\\n\\\\n#### Input\\\\n- `graph` (dict): A dictionary where each key is a node and its corresponding value is a list of nodes that it connects to. The graph is undirected, meaning if there's an edge between two nodes `u` and `v`, then there will be another edge between `v` and `u`. Each edge has a weight or cost which is not provided in the input.\\\\n\\\\n#### Output\\\\n- A list of edges that represent the minimum spanning tree of the graph. The edges are represented as tuples where each tuple contains two nodes connected by an edge.\\\\n\\\", \\\"code\\\": \\\"import heapq\\\\ndef mst(graph):\\\\n    # Initialize a dictionary to store the minimum spanning tree\\\\n    mst = []\\\\n    \\\\n    # Create a priority queue to hold all the edges in the graph\\\\n    pq = []\\\\n    for node1, neighbors in graph.items():\\\\n        for node2, weight in enumerate(neighbors):\\\\n            heapq.heappush(pq, (weight, node1, node2))\\\\n    \\\\n    # Initialize a set to keep track of visited nodes\\\\n    visited = set()\\\\n    \\\\n    # Initialize a variable to store the total cost or weight of the minimum spanning tree\\\\n    total_cost = 0\\\\n    \\\\n    while pq:\\\\n        # Extract the edge with the minimum weight from the priority queue\\\\n        weight, node1, node2 = heapq.heappop(pq)\\\\n        \\\\n        # If including this edge does not form a cycle, add it to the minimum spanning tree\\\\n        if node1 not in visited or node2 not in visited:\\\\n            mst.append((node1, node2))\\\\n            total_cost += weight\\\\n            \\\\n            # Mark both nodes as visited\\\\n            visited.add(node1)\\\\n            visited.add(node2)\\\\n    \\\\n    return mst\\\", \\\"tests\\\": [\\\"assert mst({0: [1, 2], 1: [0, 3, 4], 2: [0, 5], 3: [1], 4: [1], 5: [2]}) == [(0, 1), (1, 2), (2, 5)]\\\", \\\"assert mst({1: [2, 3], 2: [1, 3], 3: [1, 2]}) == [(1, 2), (2, 3)]\\\"] }\""
}