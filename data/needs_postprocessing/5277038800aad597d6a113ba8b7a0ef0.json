{
    "model": "gemma2:27b",
    "response": "\"{ \\\"title\\\": \\\"Hard: Labyrinth Navigation\\\", \\\"description\\\": \\\"You are given a 2D grid representing a labyrinth. Each cell can be either an empty space ('.') or a wall ('#'). You start at the top-left corner (0, 0) and your goal is to reach the bottom-right corner of the grid. You can only move up, down, left, or right one cell at a time.\\\\n\\\\n#### Function Signature\\\\n```python\\\\ndef find_path(grid: list[list[str]]) -> list[tuple[int, int]]:\\\\n```\\\\n\\\\n#### Input\\\\n- `grid` (list[list[str]]): A 2D grid representing the labyrinth. Each cell is either '.' (empty space) or '#' (wall).\\\\n\\\\n#### Output\\\\n- Returns a list of tuples representing the path from the starting point to the destination. Each tuple represents the (row, column) coordinates of a cell in the path.\\\", \\\"code\\\": \\\"def find_path(grid: list[list[str]]) -> list[tuple[int, int]]:\\\\n    rows = len(grid)\\\\n    cols = len(grid[0])\\\\n    start = (0, 0)\\\\n    end = (rows - 1, cols - 1)\\\\n\\\\n    def is_valid(row: int, col: int) -> bool:\\\\n        return 0 <= row < rows and 0 <= col < cols and grid[row][col] == '.'\\\\n\\\\n    def dfs(row: int, col: int, path: list[tuple[int, int]]) -> bool:\\\\n        if (row, col) == end:\\\\n            return True\\\\n\\\\n        path.append((row, col))\\\\n        for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\\\\n            new_row = row + dr\\\\n            new_col = col + dc\\\\n            if is_valid(new_row, new_col) and (new_row, new_col) not in path:\\\\n                if dfs(new_row, new_col, path):\\\\n                    return True\\\\n        path.pop()\\\\n        return False\\\\n    path = []\\\\n    dfs(start[0], start[1], path)\\\\n    return path\\\", \\\"tests\\\": [\\\"assert find_path([[\\\\\\\\\\\".\\\\\\\\\\\", \\\\\\\\\\\".\\\\\\\\\\\", \\\\\\\\\\\"#\\\\\\\\\\\"], [\\\\\\\\\\\"#\\\\\\\\\\\", \\\\\\\\\\\".\\\\\\\\\\\", \\\\\\\\\\\".\\\\\\\\\\\"], [\\\\\\\\\\\"#\\\\\\\\\\\", \\\\\\\\\\\".\\\\\\\\\\\", \\\\\\\\\\\".\\\\\\\\\\\"]]) == [(0, 0), (0, 1), (1, 1), (2, 1), (2, 2)]\\\", \\\"assert find_path([[\\\\\\\\\\\"#\\\\\\\\\\\", \\\\\\\\\\\"#\\\\\\\\\\\"], [\\\\\\\\\\\"#\\\\\\\\\\\", \\\\\\\\\\\"#\\\\\\\\\\\"]]) == []\\\", \\\"assert find_path([[\\\\\\\".\\\\\\\", \\\\\\\".\\\\\\\", \\\\\\\".\\\\\\\"], [\\\\\\\".\\\\\\\", \\\\\\\"#\\\\\\\", \\\\\\\".\\\\\\\"], [\\\\\\\".\\\\\\\", \\\\\\\".\\\\\\\", \\\\\\\".\\\\\\\")]) == [(0, 0), (1, 0), (2, 0)]\\\"] }\""
}