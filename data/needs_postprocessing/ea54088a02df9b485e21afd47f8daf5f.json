{
    "model": "llama3:latest",
    "response": "{\"title\": \"Medium: Tree Diameter\", \"description\": \"Given a tree with n nodes, find its diameter. The tree's nodes are labeled from 0 to n-1 and connected by edges. The function should return the length of the longest path between any two nodes.\\n\\n#### Function Signature\\n```python\\ndef tree_diameter(tree: list[list[int]]) -> int:\\n```\\n\\n#### Input\\n- `tree` (list[list[int]]): A tree represented as an adjacency list. Each inner list represents a node and contains its neighbors' labels.\\n\\n#### Output\\n- Returns the length of the longest path between any two nodes in the tree.\", \"code\": \"from collections import deque\\n\\ndef tree_diameter(tree: list[list[int]]) -> int:\\n    n = len(tree)\\n    # Perform BFS to find the maximum distance from node 0\\n    max_distance = 0\\n    queue = deque([(0, 1)])\\n    visited = set()\\n    while queue:\\n        u, d = queue.popleft()\\n        if d > max_distance:\\n            max_distance = d\\n        for v in tree[u]:\\n            if v not in visited:\\n                visited.add(v)\\n                queue.append((v, d+1))\\n    # Perform BFS again to find the maximum distance from node 0 to any leaf\\n    queue = deque([(0, 1)])\\n    max_distance = 0\\n    while queue:\\n        u, d = queue.popleft()\\n        if d > max_distance:\\n            max_distance = d\\n        for v in tree[u]:\\n            if len(tree[v]) == 1:\\n                return d + 1\\n            for w in tree[v]:\\n                if w not in visited:\\n                    visited.add(w)\\n                    queue.append((w, d+1))\\n    return -1\", \"tests\": [\"assert tree_diameter([[0,1],[1,2]] == 2\", \"assert tree_diameter([[0,1,2],[1,3],[2,4]]) == 5\", \"assert tree_diameter([[0,1,2,3,4],[1,5],[2,6],[3,7],[4,8],[5,9],[6,10],[7,11],[8,12],[9,13],[10,14],[11,15],[12,16],[13,17],[14,18],[15,19],[16,20]] == 10\", \"assert tree_diameter([[0],[1]]) == -1\"]}"
}