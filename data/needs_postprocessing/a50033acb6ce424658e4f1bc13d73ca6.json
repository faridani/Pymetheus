"{'model': 'gemma2:27b', 'response': '\"{ \\\\\"title\\\\\": \\\\\"Hard: Optimal Pathfinding in a Maze\\\\\", \\\\\"description\\\\\": \\\\\"You are given a 2D grid representing a maze. The grid contains the following characters:\\\\\\\\n\\\\\\\\n* `\\'S\\'` represents the starting point.\\\\\\\\n* `\\'E\\'` represents the end point.\\\\\\\\n* `\\'.\\'` represents an empty cell that can be traversed.\\\\\\\\n* `\\'#\\'` represents a wall that cannot be traversed.\\\\\\\\n\\\\\\\\nYour task is to write a function `find_optimal_path` that finds the shortest path from the starting point (`S`) to the ending point (`E`). The path should be represented as a list of coordinates (row, column) representing the cells traversed in order. If there is no path from `S` to `E`, return an empty list.\\\\\\\\n\\\\\\\\n#### Function Signature\\\\\\\\n```python\\\\\\\\ndef find_optimal_path(maze: list[list[str]]) -> list[tuple[int, int]]:\\\\\\\\n```\\\\\\\\n\\\\\\\\n#### Input\\\\\\\\n- `maze` (list[list[str]]): A 2D grid representing the maze.\\\\\\\\n\\\\\\\\n#### Output\\\\\\\\n- Returns a list of tuples representing the coordinates of the optimal path from `S` to `E`. If no path exists, returns an empty list.\\\\\\\\n\\\\\\\\n\\\\\", \\\\\"code\\\\\": \\\\\"from collections import deque\\\\\\\\n\\\\\\\\ndef find_optimal_path(maze: list[list[str]]) -> list[tuple[int, int]]:\\\\\\\\n    rows = len(maze)\\\\\\\\n    cols = len(maze[0])\\\\\\\\n    start = None\\\\\\\\n    end = None\\\\\\\\n\\\\\\\\n    for i in range(rows):\\\\\\\\n        for j in range(cols):\\\\\\\\n            if maze[i][j] == \\'S\\':\\\\\\\\n                start = (i, j)\\\\\\\\n            elif maze[i][j] == \\'E\\':\\\\\\\\n                end = (i, j)\\\\\\\\n    if not start or not end:\\\\\\\\n        return []\\\\\\\\n    queue = deque([(start, [])])\\\\\\\\n    visited = set([start])\\\\\\\\n\\\\\\\\n    while queue:\\\\\\\\n        (row, col), path = queue.popleft()\\\\\\\\n\\\\\\\\n        if (row, col) == end:\\\\\\\\n            return path + [(row, col)]\\\\\\\\n\\\\\\\\n        for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\\\\\\\\n            new_row = row + dr\\\\\\\\n            new_col = col + dc\\\\\\\\n            if 0 <= new_row < rows and 0 <= new_col < cols and maze[new_row][new_col] != \\'#\\' and (new_row, new_col) not in visited:\\\\\\\\n                queue.append(((new_row, new_col), path + [(row, col)]))\\\\\\\\n                visited.add((new_row, new_col))\\\\\\\\n    return []\\\\\\\\n\\\\\", \\\\\"tests\\\\\": [\\\\\"maze1 = [[\\'S\\',\\'.\\',\\'.\\'],[\\'.\\',\\'.\\',\\'E\\'],[\\'#\\',\\'#\\',\\'\\']] ; assert find_optimal_path(maze1) == [(0, 0), (0, 1), (1, 1)] \\\\\", \\\\\"maze2 = [[\\'S\\',\\'.\\',\\'#\\'],[\\'.\\',\\'E\\',\\'.\\'],[\\'#\\',\\'.\\',\\'\\']]; assert find_optimal_path(maze2) == [(0, 0), (1, 0), (2, 0)]\\\\\", \\\\\"maze3 = [[\\'S\\',\\'.\\',\\'.\\'],[\\'.\\',\\'.\\',\\'.\\'],[\\'#\\',\\'.\\',\\'E\\']]; assert len(find_optimal_path(maze3)) == 5\\\\\", \\\\\"maze4 = [[\\'S\\',\\'#\\',\\'.\\'],[\\'.\\',\\'E\\',\\'#\\'],[\\'#\\',\\'.\\',\\'\\']]; assert find_optimal_path(maze4) == []\\\\\"] }\"'}"