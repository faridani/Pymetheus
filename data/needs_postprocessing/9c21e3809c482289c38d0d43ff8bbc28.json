{
    "model": "llama3:latest",
    "response": "\"{ \\\"title\\\": \\\"Hard: Maximum Sum of Subarray K Times\\\", \\\"description\\\": \\\"Given a 1D array of integers `nums` and an integer `k`, return the maximum sum that can be obtained by choosing at most `k` distinct subarrays from `nums`. Each subarray must have a non-zero sum. A subarray is defined as any contiguous slice of `nums`.\\\\n\\\\n#### Function Signature\\\\n```python\\\\ndef max_sum_k_times(nums: list[int], k: int) -> int:\\\\n```\\\\n#### Input\\\\n- `nums` (list[int]): A 1D array of integers.\\\\n- `k` (int): The maximum number of distinct subarrays that can be chosen.\\\\n\\\\n#### Output\\\\n- Returns the maximum sum that can be obtained by choosing at most `k` distinct subarrays from `nums`.\\\\n\\\\n#### Constraints\\\\n- `0 <= k < len(nums)`\\\\n\\\\n#### Hints\\\\n- Try to find all possible subarrays with non-zero sum and sort them in descending order.\\\\n- Use a priority queue to keep track of the top `k` sums.\\\\n\\\\n\\\", \\\"code\\\": \\\"import heapq\\\\nfrom typing import List\\\\n\\\\ndef max_sum_k_times(nums: List[int], k: int) -> int:\\\\n    # Calculate all possible subarrays with non-zero sum and sort them in descending order.\\\\n    subarrays = [sum(nums[i:j]) for i in range(len(nums)) for j in range(i+1, len(nums)+1) if sum(nums[i:j]) != 0]\\\\n    subarrays.sort(reverse=True)\\\\n\\\\n    # Use a priority queue to keep track of the top k sums.\\\\n    max_sum = 0\\\\n    pq = []\\\\n    for s in subarrays:\\\\n        heapq.heappush(pq, -s)\\\\n        if len(pq) > k:\\\\n            max_sum -= heapq.heappop(pq)\\\\n    return -max_sum\\\\n\\\", \\\"tests\\\": [\\\"assert max_sum_k_times([1, 2, 3, 4], 2) == 10\\\", \\\"assert max_sum_k_times([-1, 0, 1, 2, 3], 3) == 6\\\", \\\"assert max_sum_k_times([1, -1, 1, -1], 2) == 2\\\", \\\"assert max_sum_k_times([-1000000, 1000000], 10) == 999999900\\\"] }\""
}