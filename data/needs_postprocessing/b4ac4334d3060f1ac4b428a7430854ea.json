{
    "model": "llama3:latest",
    "response": "\"{ \\\"title\\\": \\\"Easiest Path in a Maze\\\", \\\"description\\\": \\\"Write a function that finds the length of the shortest path to reach the treasure cell from the starting cell in a given maze. A cell is marked as 'T' if it contains treasure, and 'W' if it is a wall. The function should return -1 if there is no path to the treasure.\\\\n\\\\n#### Function Signature\\\\n```python\\\\ndef shortest_path(maze: list) -> int:\\\\n```\\\\n\\\\n#### Input\\\\n- `maze` (list): A 2D list of characters where 'T' marks treasure, 'W' marks a wall, and other cells are empty.\\\\n\\\\n#### Output\\\\n- Returns the length of the shortest path to reach the treasure cell from the starting cell. If there is no path, returns -1.\\\\n\\\", \\\"code\\\": \\\"\\\\nimport heapq\\\\n\\\\ndef shortest_path(maze: list) -> int:\\\\n    rows, cols = len(maze), len(maze[0])\\\\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\\\n    queue = []\\\\n    visited = [[False] * cols for _ in range(rows)]\\\\n\\\\n    def bfs(row: int, col: int) -> int:\\\\n        if row < 0 or row >= rows or col < 0 or col >= cols or maze[row][col] == 'W' or visited[row][col]:\\\\n            return -1\\\\n        if maze[row][col] == 'T':\\\\n            return 1\\\\n        visited[row][col] = True\\\\n        total_distance = 1\\\\n        for direction in directions:\\\\n            new_row, new_col = row + direction[0], col + direction[1]\\\\n            total_distance += bfs(new_row, new_col)\\\\n        return total_distance\\\\n\\\\n    start_row, start_col = None, None\\\\n    for i in range(rows):\\\\n        for j in range(cols):\\\\n            if maze[i][j] == 'T':\\\\n                treasure_row, treasure_col = i, j\\\\n            elif maze[i][j] != 'W':\\\\n                start_row, start_col = i, j\\\\n\\\\n    return bfs(start_row, start_col)\\\\n\\\", \\\"tests\\\": [\\\"assert shortest_path([['W', 'W', 'W'], ['W', 'T', 'W'], ['W', 'W', 'W']]) == 2\\\", \\\"assert shortest_path([['W', 'W', 'W'], ['W', 'T', 'T'], ['W', 'W', 'W']]) == 1\\\", \\\"assert shortest_path([['W', 'W', 'W'], ['W', 'W', 'T'], ['W', 'W', 'W']]) == -1\\\", \\\"assert shortest_path([['W', 'W', 'W'], ['W', 'T', 'T'], ['W', 'W', 'W']]) == 2\\\"] }\""
}