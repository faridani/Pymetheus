"{'model': 'gemma2:27b', 'response': '\"{ \\\\\"title\\\\\": \\\\\"Hard: Maze Escape\\\\\", \\\\\"description\\\\\": \\\\\"You are given a 2D grid representing a maze. The grid contains the following characters:\\\\\\\\n\\\\\\\\n- `\\'S\\'` : Start position.\\\\\\\\n- `\\'E\\'` : End position.\\\\\\\\n- `\\'.\\'` : Empty cell, can be traversed.\\\\\\\\n- `\\'#\\'` : Wall, cannot be traversed.\\\\\\\\n\\\\\\\\nWrite a function `escape_maze(maze)` that takes the maze as input and returns the shortest path from the start to the end. If there is no valid path, return an empty list.\\\\\\\\n\\\\\\\\n#### Function Signature\\\\\\\\n```python\\\\\\\\ndef escape_maze(maze: list[list[str]]) -> list[tuple[int, int]]:\\\\\\\\n```\\\\\\\\n\\\\\\\\n#### Input\\\\\\\\n- `maze` (list[list[str]]): A 2D grid representing the maze.\\\\\\\\n\\\\\\\\n#### Output\\\\\\\\n- Returns a list of tuples, each tuple representing the coordinates `(row, col)` of a cell in the shortest path from \\'S\\' to \\'E\\'. The list should be empty if there is no valid path.\\\\\", \\\\\"code\\\\\": \\\\\"from collections import deque\\\\\\\\n\\\\\\\\ndef escape_maze(maze: list[list[str]]) -> list[tuple[int, int]]:\\\\\\\\n    rows = len(maze)\\\\\\\\n    cols = len(maze[0])\\\\\\\\n    start = None\\\\\\\\n    end = None\\\\\\\\n\\\\\\\\n    for i in range(rows):\\\\\\\\n        for j in range(cols):\\\\\\\\n            if maze[i][j] == \\'S\\':\\\\\\\\n                start = (i, j)\\\\\\\\n            elif maze[i][j] == \\'E\\':\\\\\\\\n                end = (i, j)\\\\\\\\n\\\\\\\\n    if start is None or end is None:\\\\\\\\n        return []\\\\\\\\n\\\\\\\\n    queue = deque([(start, [])])  # Queue of (position, path)\\\\\\\\n    visited = set([start])\\\\\\\\n\\\\\\\\n    while queue:\\\\\\\\n        (row, col), path = queue.popleft()\\\\\\\\n        if (row, col) == end:\\\\\\\\n            return path + [(row, col)]\\\\\\\\n\\\\\\\\n        for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\\\\\\\\n            new_row = row + dr\\\\\\\\n            new_col = col + dc\\\\\\\\n            if (0 <= new_row < rows and 0 <= new_col < cols and \\\\\\\\n                maze[new_row][new_col] != \\'#\\' and (new_row, new_col) not in visited):\\\\\\\\n                queue.append(((new_row, new_col), path + [(row, col)]))\\\\\\\\n                visited.add((new_row, new_col))\\\\\\\\n\\\\\\\\n    return []  # No path found\\\\\", \\\\\"tests\\\\\": [\\\\\"\\'assert escape_maze([[\\'S\\',\\'.\\',\\'.\\'],[\\'.\\',\\'#\\',\\'.\\'],[ \\'.\\',\\'E\\',\\'.\\']]) == [(0, 0), (0, 1), (1, 1), (2, 1)]\\'\\\\\", \\\\\"\\'assert escape_maze([[\\'S\\',\\'.\\',\\'.\\'],[\\'#\\',\\'#\\',\\'.\\'],[ \\'.\\',\\'E\\',\\'.\\']]) == []\\'\\\\\"] }\"'}"