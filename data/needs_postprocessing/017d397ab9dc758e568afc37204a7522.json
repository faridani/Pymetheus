"{'model': 'gemma2:27b', 'response': '\"{ \\\\\"title\\\\\": \\\\\"Hard:  Optimal Path Finder\\\\\", \\\\\"description\\\\\": \\\\\"You are given a grid represented by a list of lists. Each cell in the grid can be either an empty space (represented by \\'0\\'), an obstacle (\\'X\\'), or a treasure chest (\\'T\\').\\\\\\\\n\\\\\\\\n#### Function Signature\\\\\\\\n```python\\\\\\\\ndef find_optimal_path(grid: list[list[str]]) -> int:\\\\\\\\n```\\\\\\\\n\\\\\\\\n#### Input\\\\\\\\n- `grid` (list[list[str]]): A 2D list representing the grid.\\\\\\\\n\\\\\\\\n#### Output\\\\\\\\n- Returns the minimum number of steps required to reach a treasure chest from any starting position, or -1 if there is no path.\\\\\\\\n\\\\\\\\n#### Constraints:\\\\\\\\n- The grid will be rectangular.\\\\\\\\n- There will be exactly one treasure chest (\\'T\\').\\\\\\\\n- The starting position can be any empty cell.\\\\\\\\n\\\\\", \\\\\"code\\\\\": \\\\\"from collections import deque\\\\\\\\n\\\\\\\\ndef find_optimal_path(grid: list[list[str]]) -> int:\\\\\\\\n    rows = len(grid)\\\\\\\\n    cols = len(grid[0])\\\\\\\\n    treasure_row, treasure_col = None, None\\\\\\\\n    start_positions = []\\\\\\\\n\\\\\\\\n    # Find the treasure chest and starting positions\\\\\\\\n    for i in range(rows):\\\\\\\\n        for j in range(cols):\\\\\\\\n            if grid[i][j] == \\'T\\':\\\\\\\\n                treasure_row, treasure_col = i, j\\\\\\\\n            elif grid[i][j] == \\'0\\':\\\\\\\\n                start_positions.append((i, j))\\\\\\\\n\\\\\\\\n\\\\\\\\n    # BFS to find the shortest path from any starting position to the treasure\\\\\\\\n    queue = deque([(r, c, 0) for r, c in start_positions])  # (row, col, distance)\\\\\\\\n    visited = set([(r, c) for r, c in start_positions])\\\\\\\\n\\\\\\\\n\\\\\\\\n    while queue:\\\\\\\\n        row, col, distance = queue.popleft()\\\\\\\\n        if row == treasure_row and col == treasure_col:\\\\\\\\n            return distance\\\\\\\\n\\\\\\\\n        for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\\\\\\\\n            new_row = row + dr\\\\\\\\n            new_col = col + dc\\\\\\\\n            if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] != \\'X\\' and (new_row, new_col) not in visited:\\\\\\\\n                visited.add((new_row, new_col))\\\\\\\\n                queue.append((new_row, new_col, distance + 1))\\\\\\\\n\\\\\\\\n    return -1  # No path found\\\\\", \\\\\"tests\\\\\": [\\\\\"\\'assert find_optimal_path([[\\'0\\', \\'0\\', \\'X\\', \\'T\\'], [\\'0\\', \\'X\\', \\'0\\', \\'X\\'], [\\'X\\', \\'0\\', \\'0\\', \\'0\\']]) == 4\\'\\\\\", \\\\\"\\'assert find_optimal_path([[\\'0\\', \\'X\\', \\'T\\'], [\\'0\\', \\'0\\', \\'X\\'], [\\'X\\', \\'0\\', \\'0\\']]) == 2\\'\\\\\", \\\\\"\\'assert find_optimal_path([[\\'X\\', \\'X\\', \\'X\\'], [\\'X\\', \\'T\\', \\'X\\'], [\\'X\\', \\'X\\', \\'X\\']]) == -1\\'\\\\\"] }\"'}"