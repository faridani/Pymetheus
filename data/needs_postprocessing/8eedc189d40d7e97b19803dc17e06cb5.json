"{'model': 'qwen2:7b', 'response': '{\"title\": \"KMP Pattern Searching\", \"description\": \"\\\\nThe Knuth-Morris-Pratt (KMP) algorithm is a string searching algorithm that searches for occurrences of a pattern within a text, both consisting of characters from some alphabet. The KMP algorithm uses a preprocessing function called the *failure function* or *partial match table*, which computes the longest proper prefix of each substring of the pattern that is also its suffix.\\\\n\\\\nWrite a Python function `kmp_search(text: str, pattern: str) -> List[int]` that takes in two strings, `text` and `pattern`, and returns a list of all starting indices where the pattern matches the text. The function should handle patterns and texts consisting of characters from any alphabet (including uppercase/lowercase letters, digits, punctuation).\\\\n\\\\n#### Function Signature\\\\n```python\\\\ndef kmp_search(text: str, pattern: str) -> List[int]:\\\\n```\\\\n\\\\n#### Input\\\\n- `text` (`str`): A string representing the text in which to search for occurrences of the pattern.\\\\n- `pattern` (`str`): The pattern to search for within the given text.\\\\n\\\\n#### Output\\\\n- Returns a list of integers representing the starting indices where the pattern matches the text. If no match is found, return an empty list.\\\\n\\\\n#### Constraints\\\\n- Lengths of `text` and `pattern` can be any value from 1 to 2048.\\\\n- The alphabet used in both `text` and `pattern` includes uppercase letters (`A-Z`), lowercase letters (`a-z`), digits (`0-9`), and punctuation.\\\\n\\\\n#### Example\\\\n- **Input**: text = \\\\\"Hello world\\\\\", pattern = \\\\\"world\\\\\"\\\\n- **Output**: `[6]`\\\\n- **Explanation**: The pattern \\\\\"world\\\\\" starts at index 6 in the text, ignoring case sensitivity.\\\\n\\\\n**Example**\\\\n- **Input**: text = \\\\\"The quick brown fox jumps over the lazy dog\\\\\", pattern = \\\\\"quick\\\\\"\\\\n- **Output**: `[5]`\\\\n- **Explanation**: The pattern \\\\\"quick\\\\\" starts at index 5 in the text.\", \"code\": \"\\\\nimport string\\\\n\\\\ndef kmp_search(text: str, pattern: str) -> List[int]:\\\\n    # Convert both text and pattern to lowercase for case-insensitive comparison\\\\n    text = text.lower()\\\\n    pattern = pattern.lower()\\\\n\\\\n    # Initialize a failure function vector for the pattern\\\\n    failure_function = [0] * len(pattern)\\\\n    j, prefix_suffix_index = 0, 1\\\\n    while prefix_suffix_index < len(pattern):\\\\n        if pattern[prefix_suffix_index] == pattern[j]:\\\\n            j += 1\\\\n            failure_function[prefix_suffix_index] = j\\\\n            prefix_suffix_index += 1\\\\n        elif j != 0:\\\\n            j = failure_function[j - 1]\\\\n        else:\\\\n            prefix_suffix_index += 1\\\\n\\\\n    # Search for the pattern in the text using the failure function\\\\n    result_indices = []\\\\nj, n = 0, len(text)\\\\nwhile n - j >= len(pattern):\\\\n    if pattern[n - j : n] == text[j : (j + len(pattern))]:\\\\n        result_indices.append(j)\\\\n        j += failure_function[len(pattern) - 1]\\\\n\\\\n    elif failure_function[j] != 0:\\\\n        j = j + failure_function[j]\\\\n    else:\\\\n        j += 1\\\\n\\\\n    return result_indices\", \"tests\": [\"assert kmp_search(\\\\\"Hello world\\\\\", \\\\\"world\\\\\") == [6]\", \"assert kmp_search(\\\\\"The quick brown fox jumps over the lazy dog\\\\\", \\\\\"quick\\\\\") == [5]\", \"assert kmp_search(\\\\\"A man, a plan, a canal, Panama\\\\\", \\\\\"canal\\\\\") == [7, 23]\", \"assert kmp_search(\\\\\"abcde fghij\\\\\", \\\\\"fghij\\\\\") == []\"]}'}"