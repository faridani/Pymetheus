{
    "model": "llama3:latest",
    "response": "{\"title\": \"Hard: Scheduling Tasks\", \"description\": \"You are given a list of tasks with their dependencies and durations. The tasks are represented as integers from 0 to n-1, where n is the total number of tasks. Each task has a dependency on one or more other tasks, which means it can only be started after all its dependencies have been completed. The goal is to schedule these tasks in such a way that the total time taken is minimized.\\n\\n#### Function Signature\\n```python\\ndef min_time(tasks: list[int], dependencies: list[tuple[int, int]], durations: list[int]) -> int:\\n```\\n\\n#### Input\\n- `tasks` (list[int]): A list of task IDs from 0 to n-1.\\n- `dependencies` (list[tuple[int, int]]): A list of tuples, where each tuple represents a dependency between two tasks. The first element in the tuple is the dependent task and the second element is the dependency task.\\n- `durations` (list[int]): A list of durations for each task.\\n\\n#### Output\\n- Returns the minimum time taken to complete all tasks.\", \"code\": \"\\n```\\nimport heapq\\n\\ndef min_time(tasks: list[int], dependencies: list[tuple[int, int]], durations: list[int]) -> int:\\n    # Create a graph with the given dependencies\\n    graph = {task: [] for task in range(len(tasks))}\\n    indegree = [0] * len(tasks)\\n    \\n    for dependency in dependencies:\\n        dependent_task, parent_task = dependency\\n        graph[parent_task].append(dependent_task)\\n        indegree[dependent_task] += 1\\n\\n    # Initialize a priority queue with all tasks that have no dependencies\\n    pq = [(duration, task) for task, duration in zip(durations, range(len(tasks))) if indegree[task] == 0]\\n    heapq.heapify(pq)\\n\\n    time = 0\\n    while pq:\\n        current_time, task = heapq.heappop(pq)\\n        time += current_time\\n\\n        # Update the dependencies of all tasks that depend on the current task\\n        for neighbor in graph[task]:\\n            indegree[neighbor] -= 1\\n            if indegree[neighbor] == 0:\\n                heapq.heappush(pq, (durations[neighbor], neighbor))\\n\\n    return time\", \"tests\": [\"assert min_time([2, 3, 4], [(1, 0), (2, 1)], [10, 15, 20]) == 45\", \"assert min_time([5], [], [30]) == 30\", \"assert min_time([7, 8, 9, 10], [(3, 2), (4, 2), (6, 0)], [1, 2, 3, 5]) == 24\"]}"
}