{
    "model": "llama3:latest",
    "response": "{\"title\": \"Medium: Word Chainer\", \"description\": \"Write a function `word_chain` that takes a list of words as input and returns the longest chain of connected words. Two words are considered connected if they share exactly one letter.\\n\\n#### Function Signature\\n```python\\ndef word_chain(words: list[str]) -> str:\\n```\\n\\n#### Input\\n- `words` (list[str]): A list of English words.\\n\\n#### Output\\n- Returns the longest chain of connected words as a string, where each word in the chain is separated by a space. If no chain can be formed, returns an empty string.\", \"code\": \"from collections import deque\\n\\ndef word_chain(words: list[str]) -> str:\\n    # Create a graph where each node is a word and edges are shared letters\\n    graph = {}\\n    for word in words:\\n        graph[word] = [w for w in words if sum(c1 == c2 for c1, c2 in zip(word, w)) > 0]\\n    # Perform BFS to find the longest chain of connected words\\n    max_chain = []\\n    for node in graph:\\n        visited = set()\\n        queue = deque([[node]])\\n        while queue:\\n            path = queue.popleft()\\n            if len(path) > len(max_chain):\\n                max_chain = path\\n            for neighbor in graph[node]:\\n                if neighbor not in visited:\\n                    visited.add(neighbor)\\n                    queue.append([path[-1], neighbor])\\n    # Convert the longest chain into a string and return it\\n    return ' '.join(word for word, _ in max_chain)\", \"tests\": [\"assert word_chain([\\\"apple\\\", \\\"apricot\\\", \\\"pine\\\", \\\"pineapple\\\"]) == 'apple apricot'\", \"assert word_chain([\\\"banana\\\", \\\"orange\\\", \\\"grape\\\", \\\"lemon\\\"]) == '', \\n\\\"assert word_chain([\\\"hello\", \"hell\", \"bell\", \"sell\"], \"hello hell bell sell\": \"assert word_chain([\\\"a\\\", \\\"b\\\", \\\"c\\\"]) == 'a b c'\"}"
}