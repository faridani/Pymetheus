{
    "model": "llama3:latest",
    "response": "{\"title\": \"Tournament Bracket Generation\", \"description\": \"A tournament bracket consists of a tree-like structure with a root node, where each leaf node represents a team. The goal is to generate this bracket for a given list of teams and their corresponding rankings.\\n\\n#### Function Signature\\n```\\ndef generate_bracket(teams: list[tuple[str, int]], max_depth: int) -> str:\\n```\\n\\n#### Input\\n- `teams` (list[tuple[str, int]]): A list of tuples, where each tuple contains the team name and its ranking. The length of this list represents the number of teams.\\n- `max_depth` (int): The maximum depth a team can be in the bracket tree.\\n\\n#### Output\\n- Returns a string representation of the tournament bracket, with each line representing a node in the bracket tree. The format is: `team_name (rank) -> child_team_name (child_rank)` for non-leaf nodes, and `team_name (rank)` for leaf nodes.\", \"code\": \"import heapq\\ndef generate_bracket(teams: list[tuple[str, int]], max_depth: int) -> str:\\n    # Create a priority queue to store the teams, sorted by their rankings\\n    team_queue = []\\n    for i, (team, rank) in enumerate(sorted(teams, key=lambda x: x[1])):\\n        heapq.heappush(team_queue, (-rank, f\", \"team}\": \"\", \"Root\": \"Generate the bracket tree recursively\\n    def generate_tree(queue, depth):\\n        if not queue:\\n            return\", \"f\": \"---\", \"heapq.heappop(queue)[1]}\": \"or _ in range(max_depth - depth):\\n            node +=\", \"---\": \"depth - 1)}|    \\\\\", \"queue\": \"return node\\n        child = generate_tree(queue, depth + 1)\\n        if child:\\n            return f\", \"node}{child}\": \"eturn node\\n    \\n    # Generate the bracket and add it to the result string\\n    bracket += generate_tree(team_queue, 1) +\", \"n\": \"eturn bracket\", \"tests\": [\"assert generate_bracket([(\\\"Team A\\\", 5), (\\\"Team B\\\", 3), (\\\"Team C\\\", 2)], 4) == \", \"Root\\n  ---|--- 1. Team A\\n     |    |\\n       ---|--- 2. Team B\\n         |    |\\n           ---|--- 3. Team C\", \", \\n\\\"assert generate_bracket([(\\\"Team D\", 10, \"Team E\", 8, \"Team F\", 6, 5, \"Root\\n  ---|--- 1. Team D\\n     |    |\\n       ---|--- 2. Team E\\n         |    |\\n           ---|--- 3. Team F\"]}"
}