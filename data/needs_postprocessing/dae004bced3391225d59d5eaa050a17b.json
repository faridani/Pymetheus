{
    "model": "llama3:latest",
    "response": "\"{ \\\"title\\\": \\\"Hard: Finding the Shortest Path in a Maze\\\", \\\"description\\\": \\\"A maze is represented as a 2D list of characters, where each cell contains either a wall ('#'), an empty space ('.'), or a goal ('G'). The starting point is always at the top-left corner. Write a function `find_shortest_path` that finds and returns the shortest path from the start to the goal in the maze.\\\\n\\\\n#### Function Signature\\\\n```python\\\\ndef find_shortest_path(maze: list[list[str]]) -> list[tuple[int, int]]:\\\\n```\\\\n\\\\n#### Input\\\\n- `maze` (list[list[str]]): A 2D list representing the maze. The first element of each inner list is the row index, and the second element is the column index.\\\\n- The maze contains only the characters 'G', '.', '#'.\\\\n\\\\n#### Output\\\\n- Returns a list of tuples representing the shortest path from the start to the goal in the maze. Each tuple contains the row and column indices of a cell.\\\\n\\\", \\\"code\\\": \\\"from collections import deque\\\\n\\\\ndef find_shortest_path(maze: list[list[str]]) -> list[tuple[int, int]]:\\\\n    # Find the starting point (the top-left corner)\\\\n    start = (0, 0)\\\\n    # Initialize the queue for BFS and add the starting point\\\\n    queue = deque([(start, [start])])\\\\n    # Initialize the set of visited cells\\\\n    visited = set([start])\\\\n    while queue:\\\\n        cell, path = queue.popleft()\\\\n        row, col = cell\\\\n        if maze[row][col] == 'G':  # If we've reached the goal, return the shortest path\\\\n            return path\\\\n        for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\\\\n            x, y = row + dx, col + dy\\\\n            if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and maze[x][y] != '#':  # Check if the neighboring cell is within bounds and not a wall\\\\n                neighbor = (x, y)\\\\n                if neighbor not in visited:\\\\n                    queue.append((neighbor, path + [neighbor]))\\\\n                    visited.add(neighbor)\\\\n    return []\\\", \\\"tests\\\": [\\\"assert find_shortest_path([['#', '#', '#'], ['#', '.', '#'], ['#', 'G', '#']]) == [(2, 1), (2, 0)]\\\", \\\"assert find_shortest_path([['.', '#', '#'], ['.', '.', '#'], ['G', '#', '#']]) == [(2, 0), (1, 0), (0, 0)]\\\"] }\""
}