"{'model': 'mistral-nemo:latest', 'response': '\"{ \\\\\"title\\\\\": \\\\\"Hard: Robot Paths\\\\\", \\\\\"description\\\\\": \\\\\"Given a grid of size `m x n`, where each cell can either be empty (0) or contain an obstacle (-1). A robot starts at the top-left cell and can move right or down to adjacent cells. The robot cannot move through obstacles.\\\\\\\\n\\\\\\\\n#### Function Signature\\\\\\\\n```python\\\\\\\\ndef get_shortest_paths(m: int, n: int, grid: List[List[int]]) -> List[Tuple[int, Tuple[int, int]]]:\\\\\\\\n```\\\\\\\\n\\\\\\\\n#### Input\\\\\\\\n- `m` (int): Number of rows in the grid.\\\\\\\\n- `n` (int): Number of columns in the grid.\\\\\\\\n- `grid` (List[List[int]]): A list of lists representing the grid with values -1 for obstacles and 0 for empty cells.\\\\\\\\n\\\\\\\\n#### Output\\\\\\\\n- Returns a list of tuples where each tuple contains the shortest distance to reach that cell from the top-left cell, and its coordinates as a tuple `(distance, (row, col))`.\\\\\\\\n\\\\\\\\n#### Constraints\\\\\\\\n- `1 <= m, n <= 100`\\\\\\\\n- `-1 <= grid[i][j] <= 0`\\\\\", \\\\\"code\\\\\": \\\\\"from typing import List, Tuple\\\\\\\\nimport heapq\\\\\\\\n\\\\\\\\ndef get_shortest_paths(m: int, n: int, grid: List[List[int]]) -> List[Tuple[int, Tuple[int, int]]]: \\\\\\\\n    dist = [[float(\\'inf\\')] * n for _ in range(m)]\\\\\\\\n    queue = [(0, 0, 0)]\\\\\\\\n    dist[0][0] = 0\\\\\\\\n    directions = [(1, 0), (0, 1)]\\\\\\\\n    while queue:\\\\\\\\n        d, x, y = heapq.heappop(queue)\\\\\\\\n        if d > dist[x][y]: continue\\\\\\\\n        for dx, dy in directions:\\\\\\\\n            nx, ny = x + dx, y + dy\\\\\\\\n            if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] != -1:\\\\\\\\n                nd = d + (grid[nx][ny] == 1)\\\\\\\\n                if nd < dist[nx][ny]: \\\\\\\\n                    dist[nx][ny] = nd\\\\\\\\n                    heapq.heappush(queue, (nd, nx, ny))\\\\\\\\n    return [(dist[x][y], (x, y)) for x in range(m) for y in range(n)]\\\\\", \\\\\"tests\\\\\": [\\\\\"assert get_shortest_paths(3, 4, [[0, 0, -1, 0], [0, -1, 0, 0], [-1, 0, 0, 0]]) == [(0, (0, 0)), (1, (0, 1)), (2, (0, 2)), (3, (0, 3)), (1, (1, 0)), (2, (1, 1)), (3, (1, 2)), (4, (1, 3)), (2, (2, 0)), (3, (2, 1)), (4, (2, 2)), (5, (2, 3))]\\\\\", \\\\\"assert get_shortest_paths(2, 2, [[0, 0], [0, 0]]) == [(0, (0, 0)), (1, (0, 1)), (1, (1, 0)), (0, (1, 1))]\\\\\", \\\\\"assert get_shortest_paths(1, 3, [[-1, 0, -1]]) == [(0, (0, 0)), (2, (0, 1)), (2, (0, 2))]\\\\\"] }\"'}"