"{'model': 'gemma2:27b', 'response': '{\"title\": \"Hard: Labyrinth Path Finder\", \"description\": \"You are given a 2D grid representing a labyrinth. The grid contains the following characters:\\\\n\\\\n- `\\'#\\'`: Represents a wall.\\\\n- `.`: Represents an empty cell.\\\\n- `\\'S\\'`: Represents the starting point.\\\\n- `\\'E\\'`: Represents the exit point.\\\\n\\\\nYour task is to write a function `find_path` that takes the labyrinth grid as input and returns a list of coordinates representing the shortest path from the starting point (`\\'S\\'`) to the exit point (`\\'E\\'`). If no path exists, return an empty list. You can move horizontally or vertically (up, down, left, right) but not diagonally.\\\\n\\\\n#### Function Signature\\\\n```python\\\\ndef find_path(labyrinth: list[list[str]]) -> list[tuple[int, int]]:\\\\n```\\\\n\\\\n#### Input\\\\n- `labyrinth`: A 2D list of characters representing the labyrinth grid.\\\\n\\\\n#### Output\\\\n- Returns a list of tuples representing the coordinates (row, column) of the shortest path from \\'S\\' to \\'E\\'. If no path exists, returns an empty list. \", \"code\": \"from collections import deque\\\\n\\\\ndef find_path(labyrinth: list[list[str]]) -> list[tuple[int, int]]:\\\\n    rows = len(labyrinth)\\\\n    cols = len(labyrinth[0])\\\\n    start = None\\\\n    end = None\\\\n    for i in range(rows):\\\\n        for j in range(cols):\\\\n            if labyrinth[i][j] == \\'S\\':\\\\n                start = (i, j)\\\\n            elif labyrinth[i][j] == \\'E\\':\\\\n                end = (i, j)\\\\n    if start is None or end is None:\\\\n        return []\\\\n    queue = deque([(start, [])])\\\\n    visited = set([start])\\\\n    while queue:\\\\n        (row, col), path = queue.popleft()\\\\n        if (row, col) == end:\\\\n            return path + [(row, col)]\\\\n        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]: \\\\n            new_row, new_col = row + dx, col + dy\\\\n            if 0 <= new_row < rows and 0 <= new_col < cols and labyrinth[new_row][new_col] != \\'#\\' and (new_row, new_col) not in visited:\\\\n                queue.append(((new_row, new_col), path + [(row, col)]))\\\\n                visited.add((new_row, new_col))\\\\n    return [] \", \"tests\": [\"labyrinth = [[\\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\'],\\\\n              [\\'#\\', \\'S\\', \\'.\\', \\'.\\', \\'.\\'],\\\\n              [\\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'.\\'],\\\\n              [\\'.\\', \\'.\\', \\'.\\', \\'.\\', \\'E\\'],\\\\n              [\\'#\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\']]\\\\nassert find_path(labyrinth) == [(1, 1), (1, 2), (2, 2), (3, 2), (3, 3)] \", \"labyrinth = [[\\'#\\', \\'E\\'],\\\\n             [\\'S\\', \\'.\\']]\\\\nassert find_path(labyrinth) == [(1, 1), (0, 1)],\", \"labyrinth = [[\\'#\\',\\'#\\',\\'.\\'],\\\\n              [\\'#\\',\\'S\\',\\'.\\'],\\\\n              [\\'#\\',\\'#\\',\\'E\\']] \\\\nassert find_path(labyrinth) == [(1,1),(2,1),(2,2)] \", \" labyrinth = [[\\'#\\',\\'#\\',\\'#\\'],\\\\n              [\\'#\\',\\'S\\',\\'#\\'],\\\\n              [\\'#\\',\\'#\\',\\'E\\']] \\\\nassert find_path(labyrinth) == [] \"]}'}"