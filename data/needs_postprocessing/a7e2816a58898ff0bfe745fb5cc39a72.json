{
    "model": "llama3:latest",
    "response": "{\"title\": \"Hard: Minimum Window Substring\", \"description\": \"Given two strings `s1` and `s2`, find the minimum window in `s1` that contains all characters of `s2`. If there is no such window, return an empty string.\\n\\n#### Function Signature\\n```python\\ndef min_window_substring(s1: str, s2: str) -> str:\\n```\\n\\n#### Input\\n- `s1` (str): The main string to search in.\\n- `s2` (str): The target string to find.\\n\\n#### Output\\n- Returns the minimum window substring in `s1` that contains all characters of `s2`. If no such window exists, returns an empty string.\", \"code\": \"from collections import Counter\\nimport heapq\\ndef min_window_substring(s1: str, s2: str) -> str:\\n    if not s2 or not s1:\\n        return \\\"\\\"\\n    dict_s2 = Counter(s2)\\n    required_chars = len(dict_s2)\\n    left, right = 0, 0\\n    formed_chars = 0\\n    window_counts = Counter()\\n    min_len = float('inf')\\n    min_window = \\\"\\\"\\n    while right < len(s1):\\n        character = s1[right]\\n        window_counts[character] += 1\\n        if character in dict_s2 and window_counts[character] == dict_s2[character]: \\n            formed_chars += 1\\n        while left <= right and formed_chars == required_chars:\\n            character = s1[left]\\n            if right - left + 1 < min_len:\\n                min_len = right - left + 1\\n                min_window = s1[left:right+1]\\n            window_counts[character] -= 1\\n            if character in dict_s2 and window_counts[character] < dict_s2[character]:\\n                formed_chars -= 1\\n            left += 1\\n    return min_window\", \"tests\": [\"assert min_window_substring(\\\"a\\\" * 10 + \\\"b\\\" * 5, \\\"ab\\\") == 'aaaaaab'\", \"assert min_window_substring(\\\"hello\\\", \\\"world\\\") == ''\", \"assert min_window_substring(\\\"abcba\\\", \\\"aba\\\") == 'aba'\", \"assert min_window_substring(\", \", \\\"world\\\") == '', \\\"assert min_window_substring(\\\"world\", \") == ''\"]}"
}