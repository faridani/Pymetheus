{
    "model": "llama3:latest",
    "response": "\"{ \\\"title\\\": \\\"Minimum Window Substring\\\", \\\"description\\\": \\\"Given two strings `s1` and `s2`, write a function `min_window_substring` that finds the minimum window substring of `s1` that contains all characters from `s2`. If there are multiple such substrings, return the first one.\\\\n\\\\n#### Function Signature\\\\n```python\\\\ndef min_window_substring(s1: str, s2: str) -> str:\\\\n```\\\\n\\\\n#### Input\\\\n- `s1` (str): The string to find the minimum window substring in.\\\\n- `s2` (str): The string that contains all characters that must be present in the minimum window substring.\\\\n\\\\n#### Output\\\\n- Returns the minimum window substring of `s1` that contains all characters from `s2`, or an empty string if no such substring exists.\\\\n\\\", \\\"code\\\": \\\"from collections import Counter\\\\n\\\\ndef min_window_substring(s1: str, s2: str) -> str:\\\\n    # Count the frequency of each character in both strings\\\\n    count_s1 = Counter(s1)\\\\n    count_s2 = Counter(s2)\\\\n    # Find the characters that are not present in `s2`\\\\n    missing_chars = set(count_s1) - set(count_s2)\\\\n    if any(missing_chars):\\\\n        return \\\\\\\"\\\\\\\"\\\\n    # Initialize the minimum window substring\\\\n    min_window = \\\\\\\"\\\\\\\"\\\\n    for i in range(len(s1)):\\\\n        # Check if all characters from `s2` are present in the current substring\\\\n        if set(count_s1[i:i+len(s2)]) == set(count_s2):\\\\n            # If this is the first window or it's smaller than the previous one, update it\\\\n            if not min_window or len(min_window) > i - len(s2) + 1:\\\\n                min_window = s1[i - len(s2) + 1:i+1]\\\\n    return min_window\\\", \\\"tests\\\": [\\\"assert min_window_substring('ADOBECODEBANC', 'ABC') == 'BANC'\\\", \\\"assert min_window_substring('', 'ABC') == ''\\\", \\\"assert min_window_substring('ABCCBA', 'BC') == 'BCCA'\\\", \\\"assert min_window_substring('abcabcabcabc', 'abc') == 'abc'\\\"] }\""
}