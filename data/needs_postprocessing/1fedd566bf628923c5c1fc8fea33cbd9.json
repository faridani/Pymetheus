{
    "model": "llama3:latest",
    "response": "\"{ \\\"title\\\": \\\"Minimum Window Substring\\\", \\\"description\\\": \\\"Given two strings `s1` and `s2`, find the minimum window substring of `s1` that contains all characters of `s2`. If there are multiple such windows, return the lexicographically smallest one.\\\\n\\\\n#### Function Signature\\\\n```python\\\\ndef min_window_substring(s1: str, s2: str) -> str:\\\\n```\\\\n\\\\n#### Input\\\\n- `s1` (str): The original string that contains all characters of `s2`. It may contain duplicates.\\\\n- `s2` (str): The string whose characters are contained in the minimum window substring of `s1`. It does not have any duplicate characters.\\\\n\\\\n#### Output\\\\n- Returns the lexicographically smallest minimum window substring of `s1` that contains all characters of `s2`, or an empty string if no such window exists.\\\", \\\"code\\\": \\\"\\\\nfrom collections import defaultdict\\\\n\\\\ndef min_window_substring(s1: str, s2: str) -> str:\\\\n    if not s2:\\\\n        return ''\\\\n\\\\n    s2_count = defaultdict(int)\\\\n    for char in s2:\\\\n        s2_count[char] += 1\\\\n\\\\n    required_chars = len(s2_count)\\\\n\\\\n    left = right = 0\\\\n    formed_chars = 0\\\\n\\\\n    window_counts = defaultdict(int)\\\\n\\\\n    min_len = float('inf')\\\\n    min_window = ''\\\\n\\\\n    while right < len(s1):\\\\n        if right - left + 1 >= len(s2):\\\\n            if formed_chars == required_chars:\\\\n                while left <= right and s1[left] != s2[0]:\\\\n                    window_counts[s1[left]] -= 1\\\\n                    if window_counts[s1[left]] == 0:\\\\n                        del window_counts[s1[left]]\\\\n                    left += 1\\\\n\\\\n                while right < len(s1) and formed_chars < required_chars:\\\\n                    char = s1[right]\\\\n                    window_counts[char] += 1\\\\n                    if window_counts[char] == s2_count[char]:\\\\n                        formed_chars += 1\\\\n\\\\n                for i in range(left, right + 1):\\\\n                    if all(window_counts.get(char, 0) >= s2_count[char] for char in s2_count):\\\\n                        if right - left + 1 < min_len:\\\\n                            min_len = right - left + 1\\\\n                            min_window = s1[left:right + 1]\\\\n\\\\n                left += 1\\\\n                right = 0\\\\n                formed_chars = 0\\\\n        else:\\\\n            right_char = s1[right]\\\\n            window_counts[right_char] += 1\\\\n\\\\n            if window_counts[right_char] == s2_count[right_char]:\\\\n                formed_chars += 1\\\\n\\\\n            while left <= right and formed_chars == required_chars:\\\\n                if right - left + 1 < min_len:\\\\n                    min_len = right - left + 1\\\\n                    min_window = s1[left:right + 1]\\\\n                window_counts[s1[left]] -= 1\\\\n                if window_counts[s1[left]] == 0:\\\\n                    del window_counts[s1[left]]\\\\n                left += 1\\\\n\\\\n    return min_window\\\", \\\"tests\\\": [\\\"assert min_window_substring('ADOBECODEBANC', 'ABC') == 'BANC'\\\", \\\"assert min_window_substring('abc', 'b') == 'b'\\\", \\\"assert min_window_substring('hello', 'world') == ''\\\"] }\""
}