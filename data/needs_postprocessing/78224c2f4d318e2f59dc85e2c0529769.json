{
    "model": "llama3:latest",
    "response": "{\"title\": \"Closest Pair of Points\", \"description\": \"Given a set of points in the plane, find the closest pair of points. Write a function `closest_pair` that takes as input a list of tuples representing the coordinates of the points and returns the distance between the closest pair of points.\\n\\n#### Function Signature\\n```python\\ndef closest_pair(points: List[Tuple[float, float]]) -> float:\\n```\\n\\n#### Input\\n- `points` (List[Tuple[float, float]]): A list of tuples representing the coordinates of the points in the plane. Each tuple contains two floats representing the x and y coordinates.\\n\\n#### Output\\n- Returns the distance between the closest pair of points.\", \"code\": \"import math\\n\\ndef closest_pair(points: list[tuple[float, float]]) -> float:\\n    def brute_force_distance(points):\\n        min_distance = float('inf')\\n        for i in range(len(points)):\\n            for j in range(i + 1, len(points)):\\n                distance = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2)\\n                min_distance = min(min_distance, distance)\\n        return min_distance\\n\\n    def closest_pair_strip(points, d):\\n        min_distance = d\\n        for i in range(len(points)):\\n            for j in range(i + 1, min(len(points), len(points) // 3 + 1)):\\n                if math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) < min_distance:\\n                    x_diff = abs(points[i][0] - points[j][0])\\n                    y_diff = abs(points[i][1] - points[j][1])\\n                    if x_diff > y_diff:\\n                        strip_points = [point for point in points if max(0, (points[i][0] - d) - point[0]), min(d + d, (points[i][0] + d) + point[0])]\\n                    else:\\n                        strip_points = [point for point in points if max(0, (points[i][1] - d) - point[1]), min(d + d, (points[i][1] + d) + point[1])]\\n                    min_distance = min(min_distance, brute_force_distance(strip_points))\\n        return min_distance\\n\\n    def closest_pair_recursive(points):\\n        if len(points) <= 3:\\n            return brute_force_distance(points)\\n        mid_x = points[len(points) // 2][0]\\n        left_points = [point for point in points if point[0] < mid_x]\\n        right_points = [point for point in points if point[0] >= mid_x]\\n        min_d_left = closest_pair_recursive(left_points)\\n        min_d_right = closest_pair_recursive(right_points)\\n        d = min(min_d_left, min_d_right)\\n        return min(d, closest_pair_strip(points, d))\\n\\n    return closest_pair_recursive(points)\", \"tests\": [\"assert math.isclose(closest_pair([(0.0, 0.0), (1.0, 1.0)]), 1.4142135623730951)\", \"assert math.isclose(closest_pair([(0.0, 0.0), (1.5, 2.5), (-3.0, -4.0), (-4.0, -5.0)]), 2.23606797749979)\", \"assert math.isclose(closest_pair([(-10.0, -10.0), (-9.0, -9.0), (1.0, 1.0), (11.0, 11.0)]), 14.142135623730951)\"]}"
}