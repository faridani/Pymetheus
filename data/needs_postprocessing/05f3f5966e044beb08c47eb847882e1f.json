{
    "model": "llama3:latest",
    "response": "{\"title\": \"Finding the Shortest Path in a Maze\", \"description\": \"A classic problem from graph theory, the shortest path problem asks to find the shortest path between two nodes in a weighted graph. In this case, we are given a maze represented as a 2D list of characters, where '#' represents a wall and ' ' (space) represents an open path. We also have the starting point (0, 0) and the ending point (n-1, m-1), where n is the number of rows and m is the number of columns in the maze.\\n\\n#### Function Signature\\n```python\\ndef shortest_path(maze: list[list[str]], start: tuple[int, int], end: tuple[int, int]) -> list[tuple[int, int]]:\\n```\\n\\n#### Input\\n- `maze` (list[list[str]]): A 2D list of characters representing the maze.\\n- `start` (tuple[int, int]): The starting point in the maze (0-indexed).\\n- `end` (tuple[int, int]): The ending point in the maze (0-indexed).\\n\\n#### Output\\n- Returns a list of coordinates (tuples) representing the shortest path from the start to the end.\", \"code\": \"\\nimport heapq\\nfrom typing import List, Tuple\\n\\ndef shortest_path(maze: List[List[str]], start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]:\\n    # Define the directions for DFS/BFS\\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\n\\n    # Create a priority queue to store nodes to visit\\n    queue = [(0, start)]\\n    visited = set()\\n    shortest_path = []\\n\\n    while queue:\\n        # Extract the node with the minimum distance from the queue\\n        dist, current = heapq.heappop(queue)\\n\\n        # If we have reached the end node, construct the path and return it\\n        if current == end:\\n            while current != start:\\n                for d in directions:\\n                    if (current[0] + d[0], current[1] + d[1]) not in visited:\\n                        new_dist = dist - 1\\n                        heapq.heappush(queue, (new_dist, (current[0] + d[0], current[1] + d[1])))\\n                        visited.add((current[0] + d[0], current[1] + d[1]))\\n                        shortest_path.append((current[0] + d[0], current[1] + d[1]))\\n                        current = (current[0] + d[0], current[1] + d[1])\\n            return shortest_path[::-1]\\n\\n        # Mark the node as visited\\n        visited.add(current)\\n\\n        # Explore neighboring nodes\\n        for direction in directions:\\n            neighbor = (current[0] + direction[0], current[1] + direction[1])\\n\\n            # Check if the neighbor is within the maze and not a wall\\n            if 0 <= neighbor[0] < len(maze) and 0 <= neighbor[1] < len(maze[0]) and maze[neighbor[0]][neighbor[1]] == ' ':\\n                # Calculate the distance to the neighbor\\n                new_dist = dist + 1\\n\\n                # If the neighbor has not been visited before, add it to the queue\\n                if neighbor not in visited:\\n                    heapq.heappush(queue, (new_dist, neighbor))\\n\\n    return []  # Return an empty list if no path is found\", \"tests\": [\"assert shortest_path([['#', '#', '#'], ['#', ' ', '#'], ['#', '#', '#']], (0, 0), (2, 1)) == [(0, 0), (0, 1), (1, 1), (2, 1)],\", \"assert shortest_path([['#', '#', '#'], ['#', ' ', '#'], ['#', '#', '#']], (0, 0), (0, 2)) == [(0, 0), (0, 1), (0, 2)],\", \"assert shortest_path([['#', '#', '#'], ['#', ' ', '#'], ['#', '#', '#']], (0, 0), (1, 0)) == [(0, 0), (1, 0)],\"]}"
}