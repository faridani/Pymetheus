{
    "model": "llama3:latest",
    "response": "[{\"title\": \"Minimum Spanning Tree\", \"description\": \"In computer science, a minimum spanning tree (MST) or minimum weight spanning tree for a connected, edge-weighted graph is a subgraph that connects all the vertices together, without any cycles and with the minimum possible total edge weight. Given an undirected weighted graph represented as an adjacency list, write a function to find the Minimum Spanning Tree (MST). \\n\\n#### Function Signature\\n```python\\ndef min_spanning_tree(graph: dict) -> int:\\n```\\n\\n#### Input\\n- `graph` (dict): An adjacency list representation of an undirected weighted graph. The keys are node IDs, and the values are dictionaries where each key is a neighbor's ID and each value is the weight of the edge between them.\\n\\n#### Output\\n- Returns the total minimum weight of the MST.\", \"code\": \"\\nimport heapq\\n\\ndef min_spanning_tree(graph: dict) -> int:\\n    # Initialize variables\\n    nodes = set()\\n    edges = []\\n\\n    # Populate nodes and edges\\n    for node\", \"graph.items()\": \"nodes.add(node)\\n        for neighbor\", \"neighbors.items()\": \"edges.append((weight\", \"node\": \"node for node in nodes\"}, {\"node\": 0, \"edges\": \"weight\", \"parent)\": \"union(node1\", \"find(node\": \"str\", \"parent\": \"dict\", \"union(node1\": \"str\", \"node2\": \"str\", \"rank\": \"dict) -> None:\\n    root1 = find(node1\", \"rank[root2]\": \"parent[root2] = root1\\n    elif rank[root1] < rank[root2]:\\n        parent[root1] = root2\\n    else:\\n        parent[root2] = root1\\n        rank[root1] += 1\\n\\n# Example test case\\nassert min_spanning_tree({'A': {'B': 2\", \"C\": 3}, {\"A\": 2, \"D\": 4}, {\"A\": 3}, {\"B\": 4}]"
}