{
    "model": "llama3:latest",
    "response": "\"{ \\\"title\\\": \\\"Finding the Shortest Path\\\", \\\"description\\\": \\\"You are given a grid of size N x M, where each cell contains either 0 or 1. You want to find the shortest path from the top-left corner (cell (0,0)) to the bottom-right corner (cell (N-1,M-1)). The rules for moving are:\\\\n\\\\n* You can only move down or right.\\\\n* You cannot visit a cell that has already been visited.\\\\n\\\\nWrite a function `shortest_path` that returns the minimum number of steps required to reach the bottom-right corner. If there is no path, return -1.\\\", \\\"code\\\": \\\"\\\\n```\\\\nimport heapq\\\\n\\\\ndef shortest_path(grid):\\\\n    N = len(grid)\\\\n    M = len(grid[0])\\\\n    queue = [(0, 0, 0)]  # (steps, row, col)\\\\n    visited = set((0, 0))\\\\n    directions = [(0, 1), (1, 0)]\\\\n\\\\n    while queue:\\\\n        steps, row, col = heapq.heappop(queue)\\\\n        if row == N-1 and col == M-1:\\\\n            return steps\\\\n\\\\n        for dr, dc in directions:\\\\n            nr, nc = row + dr, col + dc\\\\n            if 0 <= nr < N and 0 <= nc < M and (nr, nc) not in visited and grid[nr][nc] == 0:\\\\n                heapq.heappush(queue, (steps+1, nr, nc))\\\\n                visited.add((nr, nc))\\\\n\\\\n    return -1\\\\n\\\\n```\\\\n\\\", \\\"tests\\\": [\\\"assert shortest_path([[0, 0], [0, 0], [1, 1]]) == 3\\\", \\\"assert shortest_path([[0, 0], [0, 1], [1, 1]]) == 2\\\", \\\"assert shortest_path([[0, 0], [1, 0], [1, 1]]) == -1\\\", \\\"assert shortest_path([[0, 0, 0], [0, 1, 0], [0, 1, 1]]) == 5\\\"] }\""
}