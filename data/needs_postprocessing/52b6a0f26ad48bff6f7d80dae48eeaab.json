"{'model': 'phi4:latest', 'response': '\"{ \\\\\"title\\\\\": \\\\\"Hard: Optimal Path Sum with Obstacles\\\\\", \\\\\"description\\\\\": \\\\\"You are given a grid of integers representing different costs, and some cells contain obstacles that cannot be traversed. Your task is to find the minimum cost path from the top-left corner to the bottom-right corner of the grid, moving only right or down at each step.\\\\\\\\n\\\\\\\\nThe input consists of:\\\\\\\\n1. An integer `n` (2 <= n <= 100) representing the size of the grid (n x n).\\\\\\\\n2. A list of lists `grid`, where each element is either a non-negative integer representing the cost of stepping into that cell, or -1 indicating an obstacle.\\\\\\\\nThe top-left and bottom-right corners are guaranteed to be free from obstacles.\\\\\\\\n\\\\\\\\nYour function should return the minimum cost to reach the bottom-right corner from the top-left corner. If it\\'s not possible to reach the destination, return -1.\\\\\\\\n\\\\\\\\n#### Function Signature\\\\\\\\n```python\\\\\\\\ndef min_path_cost(n: int, grid: List[List[int]]) -> int:\\\\\\\\n```\\\\\\\\n\\\\\\\\n#### Input\\\\\\\\n- `n` (int): The size of the grid.\\\\\\\\n- `grid` (List[List[int]]): A 2D list representing the cost grid with obstacles (-1).\\\\\\\\n\\\\\\\\n#### Output\\\\\\\\n- Returns an integer representing the minimum path cost, or -1 if no such path exists.\\\\\", \\\\\"code\\\\\": \\\\\"from typing import List\\\\\\\\nimport heapq\\\\\\\\n\\\\\\\\ndef min_path_cost(n: int, grid: List[List[int]]) -> int:\\\\\\\\n    # Create a priority queue and push the starting point (0, 0) with cost 0\\\\\\\\n    pq = [(0, 0, 0)]  # (cost, x, y)\\\\\\\\n    # Distances array to store minimum costs for each cell; initialize with infinity\\\\\\\\n    dist = [[float(\\'inf\\')] * n for _ in range(n)]\\\\\\\\n    dist[0][0] = 0\\\\\\\\n    \\\\\\\\n    # Deltas for moving right or down\\\\\\\\n    directions = [(1, 0), (0, 1)]\\\\\\\\n    \\\\\\\\n    while pq:\\\\\\\\n        current_cost, x, y = heapq.heappop(pq)\\\\\\\\n        \\\\\\\\n        # If we\\'ve reached the bottom-right corner, return the cost\\\\\\\\n        if x == n - 1 and y == n - 1:\\\\\\\\n            return current_cost\\\\\\\\n        \\\\\\\\n        for dx, dy in directions:\\\\\\\\n            nx, ny = x + dx, y + dy\\\\\\\\n            \\\\\\\\n            # Check boundaries and obstacles\\\\\\\\n            if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] != -1:\\\\\\\\n                new_cost = current_cost + grid[nx][ny]\\\\\\\\n                \\\\\\\\n                # If a shorter path to (nx, ny) is found\\\\\\\\n                if new_cost < dist[nx][ny]:\\\\\\\\n                    dist[nx][ny] = new_cost\\\\\\\\n                    heapq.heappush(pq, (new_cost, nx, ny))\\\\\\\\n    \\\\\\\\n    # If we exit the loop without reaching the bottom-right corner, return -1\\\\\\\\n    return -1\\\\\", \\\\\"tests\\\\\": [\\\\\"assert min_path_cost(3, [[0, 1, 2], [1, -1, 1], [4, 5, 0]]) == 7\\\\\", \\\\\"assert min_path_cost(3, [[0, 2, 2], [-1, -1, 2], [1, 1, 0]]) == -1\\\\\", \\\\\"assert min_path_cost(2, [[0, 1], [1, 0]]) == 2\\\\\", \\\\\"assert min_path_cost(4, [[0, 3, 5, 9], [8, 1, 3, 4], [5, 0, 6, 7], [4, 3, 2, 0]]) == 16\\\\\"] }\"'}"