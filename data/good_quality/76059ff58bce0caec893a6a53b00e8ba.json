{
    "title": "Difficult: Tree Traversals",
    "description": "Write a function `tree_traversal` that takes the root of a binary tree as input and returns a list of integers representing the pre-order, in-order, and post-order traversals. For example, given the following binary tree:\n```\n    1\n   / \\\n  2   3\n / \\ \\/\n4   5 6\n```\nThe function should return `[1, 2, 4, 5, 3, 6]` for the pre-order traversal,\n`[4, 2, 5, 1, 3, 6]` for the in-order traversal, and `[1, 5, 6, 3, 2, 4]` for the post-order traversal.\n\n#### Function Signature\n```python\ndef tree_traversal(root: 'Node') -> list:\n```\n\n#### Input\n- `root` (Node): The root of a binary tree.\n\n#### Output\n- Returns a list of three integers representing the pre-order, in-order, and post-order traversals.",
    "code": "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef tree_traversal(root: 'Node') -> list:\n    pre_order = []\n    in_order = []\n    post_order = []\n    current_node = root\n\n    while True:\n        if current_node is not None:\n            pre_order.append(current_node.value)\n            in_order.append(current_node.value)\n            post_order.insert(0, current_node.value)\n            current_node = current_node.left\n        elif current_node is None and len(pre_order) > 0:\n            rightmost_node = None\n            while True:\n                if len(in_order) > 0 and in_order[-1] == pre_order[0]:\n                    in_order.pop()\n                    post_order.insert(0, pre_order[0])\n                    pre_order.pop(0)\n                elif current_node is not None and current_node.value == in_order[-1]:\n                    current_node = current_node.right\n                else:\n                    break\n            current_node = rightmost_node if rightmost_node is not None else root\n        elif len(post_order) > 0:\n            break\n    return [pre_order, in_order, post_order]",
    "tests": [
        "assert tree_traversal(Node(1, Node(2, Node(4), Node(5)), Node(3, Node(6)))) == [[1, 2, 4, 5, 3, 6], [4, 2, 5, 1, 3, 6], [1, 5, 6, 3, 2, 4]]",
        "assert tree_traversal(Node(5, Node(2, Node(1), None), Node(8))) == [[5, 2, 1, 8], [1, 2, 5, 8], [5, 8, 2, 1]]"
    ],
    "difficulty": "insanely difficult",
    "model": "llama3:latest",
    "style": "Codewars"
}