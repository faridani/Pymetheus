{
    "title": "Minimum Time to Reach All Buildings",
    "description": "You are given a 2D array `buildings` where each row represents a building's height. The goal is to find the minimum time required to reach all buildings from the starting point at position `(0, 0)`.\n\nEach day, you can move either up (`+1`) or right (`+1`) from your current position. You need to visit every building exactly once and return to the starting point. You are allowed to revisit previously visited buildings as many times as needed.\n\nYour function should take a 2D array `buildings` as input, where each row represents a building's height. It should return the minimum time required to reach all buildings from the starting position `(0, 0)`.\n\n#### Function Signature\n```\ndef min_time_to_reach_all_buildings(buildings: list[list[int]]) -> int:\n```\n\n#### Input\n- `buildings` (list[list[int]]): A 2D array where each row represents a building's height.\n\n#### Output\n- Returns the minimum time required to reach all buildings from the starting position `(0, 0)`.\n\n#### Constraints\nThe number of rows and columns in the input array will be within the range `[1, 100]`. Each building's height will be an integer between `0` and `10`.",
    "code": "\nimport heapq\n\ndef min_time_to_reach_all_buildings(buildings: list[list[int]]) -> int:\n    # Create a priority queue to keep track of the buildings that are yet to be visited\n    pq = [(height, i, 0) for i, row in enumerate(buildings) for height in row]\n    heapq.heapify(pq)\n\n    # Initialize the total time and the current position\n    total_time = 0\n    pos = (0, 0)\n\n    while pq:\n        # Get the building with the highest height from the priority queue\n        height, i, j = heapq.heappop(pq)\n\n        # If this is not the starting point, increment the time by the distance to the current position\n        if pos != (i, j):\n            total_time += abs(i - pos[0]) + abs(j - pos[1])\n\n        # Mark the current building as visited\n        buildings[i][j] = 0\n\n        # Add all unvisited neighboring buildings to the priority queue\n        for ni in range(max(0, i-1), min(len(buildings), i+2)):\n            for nj in range(max(0, j-1), min(len(buildings[0]), j+2)):\n                if buildings[ni][nj] > 0:\n                    heapq.heappush(pq, (buildings[ni][nj], ni, nj))\n\n        # Update the current position\n        pos = (i, j)\n\n    return total_time",
    "tests": [
        "assert min_time_to_reach_all_buildings([[1], [2], [3]]) == 7",
        "assert min_time_to_reach_all_buildings([[0], [0], [10]]) == 11",
        "assert min_time_to_reach_all_buildings([[5, 5, 5], [5, 5, 5], [5, 5, 5]]) == 9"
    ],
    "difficulty": "insanely difficult",
    "model": "llama3:latest",
    "style": "AtCoder"
}