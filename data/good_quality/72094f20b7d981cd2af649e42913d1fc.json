{
    "title": "Hard: Binary Tree to Linked List",
    "description": "Write a function `tree_to_linked_list` that takes the root of a binary tree and returns its equivalent linked list. The linked list should have the same nodes as the binary tree, but in the order they would be visited if the tree were traversed level-order (also known as breadth-first).\n\n#### Function Signature\n```python\ndef tree_to_linked_list(root: TreeNode) -> LinkedList:\n```\n\n#### Input\n- `root` (TreeNode): The root of a binary tree.\n\n#### Output\n- A linked list with the same nodes as the input tree, in level-order traversal.",
    "code": "\nimport collections\n\nclass TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n\ndef tree_to_linked_list(root: TreeNode) -> LinkedList:\n    if root is None:\n        return LinkedList()\n\n    queue = collections.deque([(root, 0)])\n    linked_list = LinkedList()\n    visited = set()\n\n    while queue:\n        node, level = queue.popleft()\n        if node not in visited:\n            visited.add(node)\n            new_node = LinkedListNode(node.value)\n\n            if linked_list.head is None:\n                linked_list.head = new_node\n            else:\n                current = linked_list.head\n                prev_level = -1\n\n                while current and current.level == prev_level:\n                    prev_level = current.level\n                    current = current.next\n\n                if new_node.level > prev_level:\n                    new_node.next = LinkedListNode(None)\n                    new_node.next.prev = new_node\n                    new_node.next.next = None\n                    linked_list.head = new_node\n                else:\n                    while current and current.level <= new_node.level:\n                        current = current.next\n                    if current:\n                        current.prev = new_node\n                        new_node.next = current\n\n            for child in [node.left, node.right]:\n                if child:\n                    queue.append((child, level + 1))\n\n    return linked_list\n\nclass LinkedListNode:\n    def __init__(self, value):\n        self.value = value\n        self.level = 0\n        self.prev = None\n        self.next = None",
    "tests": [
        "assert tree_to_linked_list(None).head is None",
        "assert tree_to_linked_list(TreeNode(1)).head.value == 1 and tree_to_linked_list(TreeNode(1)).head.next is None",
        "assert tree_to_linked_list(TreeNode(1, TreeNode(2), TreeNode(3))).head.value == 1 and tree_to_linked_list(TreeNode(1, TreeNode(2), TreeNode(3))).head.next.value == 2 and tree_to_linked_list(TreeNode(1, TreeNode(2), TreeNode(3))).head.next.next.value == 3",
        "assert tree_to_linked_list(TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(6, TreeNode(7), TreeNode(8)))).head.value == 1 and tree_to_linked_list(TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(6, TreeNode(7), TreeNode(8)))).head.next.value == 2 and tree_to_linked_list(TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(6, TreeNode(7), TreeNode(8)))).head.next.next.value == 4 and tree_to_linked_list(TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(6, TreeNode(7), TreeNode(8)))).head.next.next.next.value == 5"
    ],
    "difficulty": "super hard",
    "model": "llama3:latest",
    "style": "Codewars"
}