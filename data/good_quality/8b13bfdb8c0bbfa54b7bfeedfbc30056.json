{
    "title": "Hard: Prime Spiral",
    "description": "Prime numbers are numbers greater than 1 that have no divisors other than 1 and themselves. The prime spiral is a pattern of prime numbers arranged in a spiral shape, starting from the center of the grid. Write a function `prime_spiral` that generates the next cell of the prime spiral.\n\nThe function should take two parameters: the current cell coordinates (x, y) and the last generated prime number (`last_prime`). The function should return the next cell coordinates (x, y) and the next prime number to be added in the grid.\n\nYou can start generating from any center cell. You can also assume that you will generate all primes up to a certain maximum number.\n\nThe spiral grows outward in a right-handed sense, meaning that when moving from one cell to the next, you move either down, then right, then up, or then left.\n\n#### Function Signature\n```python\ndef prime_spiral(x: int, y: int, last_prime: int) -> (int, int, int):\n```\n\n#### Input\n- `x` (int): The current x-coordinate of the cell.\n- `y` (int): The current y-coordinate of the cell.\n- `last_prime` (int): The last prime number generated.\n\n#### Output\n- Returns a tuple `(x, y, next_prime)` where:\n  - `x` and `y` are the coordinates of the next cell in the spiral.\n  - `next_prime` is the next prime number to be added to the grid.",
    "code": "\nimport math\n\ndef sieve_of_eratosthenes(n):\n    primes = [True] * (n + 1)\n    primes[0] = primes[1] = False\n    p = 2\n    while p * p <= n:\n        if primes[p]:\n            for i in range(p * p, n + 1, p):\n                primes[i] = False\n        p += 1\n    return [p for p in range(2, n + 1) if primes[p]]\n\ndef prime_spiral(x: int, y: int, last_prime: int) -> (int, int, int):\n    max_num = 1000000\n    primes = sieve_of_eratosthenes(max_num)\n    next_prime_index = primes.index(last_prime)\n    x_directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    directions = [(x_directions[0][0], x_directions[0][1])]\n\n    for _ in range(next_prime_index):\n        next_x = x + directions[-1][0]\n        next_y = y + directions[-1][1]\n        if next_x < 0 or next_x >= len(primes) or next_y < 0:\n            return (x, y, -1)\n        if primes[next_x]:\n            return ((next_x, next_y), next_x)\n\n    x += 1\n    for _ in range(next_prime_index):\n        next_x = x + directions[-1][0]\n        next_y = y + directions[-1][1]\n        if next_x < 0 or next_x >= len(primes) or next_y < 0:\n            return (x, y, -1)\n        if primes[next_x]:\n            return ((next_x, next_y), next_x)\n\n    for _ in range(next_prime_index):\n        directions.append(x_directions[-1])\n        x += 1\n        for _ in range(next_prime_index):\n            next_x = x + directions[-1][0]\n            next_y = y + directions[-1][1]\n            if next_x < 0 or next_x >= len(primes) or next_y < 0:\n                return (x, y, -1)\n            if primes[next_x]:\n                return ((next_x, next_y), next_x)\n\n    return (x, y, -1)",
    "tests": [
        "assert prime_spiral(0, 0, 2) == ((3, 1), 5)",
        "assert prime_spiral(-1, 0, 5) == ((-2, 0), -1)",
        "assert prime_spiral(-1, 1, 7) == ((-2, 1), -1)",
        "assert prime_spiral(10, 6, 17) == ((11, 4), 19)"
    ],
    "difficulty": "super hard",
    "model": "llama3:latest",
    "style": "AtCoder"
}