{
    "title": "Eulerian Path Finder",
    "description": "An Eulerian path is a sequence of vertices that visits each edge exactly once. Given an undirected graph represented as an adjacency list, write a function `find_eulerian_path` that finds the longest possible Eulerian path in the graph.\n\n#### Function Signature\n```python\ndef find_eulerian_path(graph: dict) -> list:\n```\n\n#### Input\n- `graph` (dict): A dictionary where each key is a node and its corresponding value is a list of neighboring nodes.\n\n#### Output\n- Returns the longest possible Eulerian path as a list of nodes. If no such path exists, returns an empty list.",
    "code": "\nimport collections\n\ndef find_eulerian_path(graph):\n    in_degree = {node: 0 for node in graph}\n    out_degree = {node: 0 for node in graph}\n\n    # Calculate in-degree and out-degree of each node\n    for node, neighbors in graph.items():\n        out_degree[node] = len(neighbors)\n        for neighbor in neighbors:\n            in_degree[neighbor] += 1\n\n    # Find nodes with odd in-degree (odd number of incoming edges) or out-degree (odd number of outgoing edges)\n    odd_nodes = [node for node, degree in in_degree.items() if degree % 2 != 0]\n    odd_nodes.extend([node for node, degree in out_degree.items() if degree % 2 != 0])\n\n    # If there are no nodes with odd degree, the graph is not Eulerian\n    if len(odd_nodes) == 0:\n        return []\n\n    # Start from an arbitrary node and follow the Eulerian path\n    current_node = random.choice(odd_nodes)\n    path = [current_node]\n    while True:\n        next_node = None\n        for neighbor in graph[current_node]:\n            if out_degree[neighbor] > 0:\n                next_node = neighbor\n                break\n        if next_node is None:\n            # If we've reached a node with no outgoing edges, backtrack until we find one\n            backtracking_node = current_node\n            while True:\n                for neighbor in graph[backtracking_node]:\n                    if out_degree[neighbor] > 0:\n                        next_node = neighbor\n                        break\n                if next_node is not None:\n                    break\n                backtracking_node = previous_backtracking_node\n            previous_backtracking_node = backtracking_node\n        else:\n            current_node = next_node\n            path.append(current_node)\n        out_degree[current_node] -= 1\n\n    return path[::-1]",
    "tests": [
        "assert find_eulerian_path({\"A\":[\"B\", \"C\"] , \"B\": [\"A\",\"D\"] , \"C\": [\"A\",\"F\"] , \"D\":[\"B\"] , \"E\": [\"F\"] , \"F\":[\"C\",\"E\"]}) == ['A', 'C', 'F', 'E', 'B', 'D', 'A']",
        "assert find_eulerian_path({\"A\":[\"B\", \"C\"] , \"B\": [\"A\"] , \"C\": [\"A\"]}) == []"
    ],
    "difficulty": "super hard",
    "model": "llama3:latest",
    "style": "Interview Query"
}