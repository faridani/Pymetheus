{
    "title": "Eulerian Cycles",
    "description": "Given a directed graph with N nodes and M edges, find all possible Eulerian cycles. An Eulerian cycle is a path that visits every edge exactly once.\n\n#### Function Signature\n```python\ndef eulerian_cycles(graph: list[list[int]]) -> list[list[int]]:\n```\n\n#### Input\n- `graph` (list[list[int]]): A directed graph represented as an adjacency list. Each inner list represents the edges leaving a node, and each edge is represented by its target node.\n\n#### Output\n- Returns a list of all possible Eulerian cycles in the graph. Each cycle is represented as a list of nodes.",
    "code": "",
    "\nimport itertools\n\ndef eulerian_cycles(graph):\n    n = len(graph)\n    edges_in = [0] * n\n    edges_out = [0] * n\n    \n    for edge_list in graph:\n        for edge in edge_list:\n            edges_out[edge] += 1\n            edges_in[edge] -= 1\n    \n    in_degree = [(i, degree) for i, degree in enumerate(edges_in) if degree != 0]\n    out_degree = [(i, degree) for i, degree in enumerate(edges_out) if degree != 0]\n    \n    def dfs(node, path):\n        while True:\n            path.append(node)\n            next_node = None\n            for edge in graph[node]:\n                if edge not in path and edges_in[edge] > 0:\n                    next_node = edge\n                    break\n            if next_node is None or edges_out[next_node] == 0:\n                return path, [i for i, j in zip(path, range(len(path))) if j % 2 == 1]\n            else:\n                for _ in range(edges_in[next_node]):\n                    graph[node].remove(next_node)\n                    graph[next_node].append(node)\n                    edges_out[next_node] -= 1\n                    next_node = None\n                    break\n                return dfs(next_node, path)\n\n    cycles = []\n    for node in out_degree:\n        if node[1] > 0 and node[1] % 2 == 0:\n            _, end_nodes = dfs(node[0], [])\n            if len(end_nodes) > 0:\n                cycle = [node[0]]\n                for i, node in enumerate(cycle):\n                    next_node = None\n                    for edge in graph[node]:\n                        if edge not in cycle and edges_in[edge] > 0:\n                            next_node = edge\n                            break\n                    cycle.append(next_node)\n                    for _ in range(edges_in[next_node]):\n                        graph[node].remove(next_node)\n                        graph[next_node].append(node)\n                        edges_out[next_node] -= 1\n                cycles.append(cycle)\n    return [cycle[1:] for cycle in itertools.permutations(list(itertools.chain(*cycles)), len(cycles[0]))]": "",
    "tests": [
        "assert eulerian_cycles([[0, 1], [1, 2], [2, 3], [3, 4]]) == [[0, 1, 2, 3, 4]]",
        "assert eulerian_cycles([[0, 1], [1, 0], [2, 3], [3, 2], [4, 5], [5, 4]]) == [[0, 1, 0], [2, 3, 2], [4, 5, 4]]",
        "assert eulerian_cycles([[0, 1], [1, 2], [2, 3], [3, 4]]) == []"
    ],
    "difficulty": "insanely difficult",
    "model": "llama3:latest",
    "style": "Google Code Jam"
}