{
    "title": "Graph Cycle Coloring - Hard",
    "description": "You are given an undirected graph with \\(n\\) vertices and \\(m\\) edges. Each edge has a color, either red or blue. Your task is to determine if it is possible to assign each vertex one of two colors (say 'A' or 'B') such that no edge connects vertices of the same color.\n\n#### Function Signature\n```python\ndef can_two_color_graph(n: int, edges: List[Tuple[int, int, str]]) -> bool:\n```\n\n#### Input\n- `n` (int): The number of vertices in the graph. \\(1 \\leq n \\leq 1000\\)\n- `edges` (List[Tuple[int, int, str]]): A list of tuples where each tuple represents an edge as two vertex indices and a string ('red' or 'blue') indicating its color.\n\n#### Output\n- Returns `True` if it is possible to assign colors to the vertices such that no same-colored edges connect vertices of the same color. Otherwise, returns `False`.\n\n#### Constraints\n- The graph may be disconnected.\n- Each vertex index will be between 1 and \\(n\\) inclusive.\n- No multiple edges or self-loops are present in the graph.\n- Each edge is either red or blue.\n\n#### Hints\n- Consider using a graph coloring algorithm with BFS/DFS to check bipartiteness of subgraphs for each color.",
    "code": "from typing import List, Tuple\n\ndef can_two_color_graph(n: int, edges: List[Tuple[int, int, str]]) -> bool:\n    from collections import defaultdict, deque\n    \n    def bfs_check_bipartite(start, adj_list):\n        color = [-1] * (n + 1)\n        queue = deque([start])\n        color[start] = 0\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj_list[node]:\n                if color[neighbor] == -1:  # Not colored yet\n                    color[neighbor] = 1 - color[node]\n                    queue.append(neighbor)\n                elif color[neighbor] == color[node]:  # Same color as the node, not bipartite\n                    return False\n        return True\n    \n    red_adj_list = defaultdict(list)\n    blue_adj_list = defaultdict(list)\n    \n    for u, v, color in edges:\n        if color == 'red':\n            red_adj_list[u].append(v)\n            red_adj_list[v].append(u)\n        else:\n            blue_adj_list[u].append(v)\n            blue_adj_list[v].append(u)\n    \n    # Check bipartiteness for both red and blue subgraphs\n    for i in range(1, n + 1):\n        if not bfs_check_bipartite(i, red_adj_list) or not bfs_check_bipartite(i, blue_adj_list):\n            return False\n    \n    return True\n",
    "tests": [
        "assert can_two_color_graph(3, [(1, 2, 'red'), (2, 3, 'blue')]) == True",
        "assert can_two_color_graph(3, [(1, 2, 'red'), (2, 3, 'red'), (3, 1, 'red')]) == False",
        "assert can_two_color_graph(4, [(1, 2, 'blue'), (2, 3, 'red'), (3, 4, 'blue'), (4, 1, 'red')]) == True",
        "assert can_two_color_graph(5, [(1, 2, 'red'), (2, 3, 'blue'), (3, 4, 'red'), (4, 5, 'blue'), (5, 1, 'red'), (1, 3, 'blue')]) == False"
    ],
    "difficulty": "insanely difficult",
    "model": "phi4:latest",
    "style": "Codeforces"
}