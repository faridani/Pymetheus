{
    "title": "Hard: Dynamic Programming with Bit Manipulation - Knapsack Problem with Item Grouping",
    "description": "You are given a set of items, each with a weight and a value. Your task is to determine the maximum value that can be obtained by selecting a subset of these items such that their total weight does not exceed a given limit. However, there's an additional constraint: certain items must either all be included or all be excluded together if they belong to the same group.\n\nWrite a function `max_knapsack_value_with_groups` that implements this modified knapsack problem using dynamic programming and bit manipulation techniques.\n\n#### Function Signature\n```python\ndef max_knapsack_value_with_groups(weights: List[int], values: List[int], max_weight: int, groups: List[List[int]]) -> int:\n```\n\n#### Input\n- `weights` (List[int]): A list of integers where each integer represents the weight of an item.\n- `values` (List[int]): A list of integers where each integer represents the value of an item.\n- `max_weight` (int): An integer representing the maximum allowable total weight.\n- `groups` (List[List[int]]): A list of groups, where each group is a list of indices into `weights` and `values`. Items in the same group must be included or excluded together.\n\n#### Output\n- Returns an integer representing the maximum value that can be achieved under the given constraints.\n\n#### Constraints\n- 1 <= len(weights) == len(values) <= 1000\n- 1 <= weights[i], values[i] <= 1000 for each valid index i\n- 1 <= max_weight <= 10000\n- 0 <= len(groups) <= 100\n\n#### Hints\n- Use dynamic programming to solve the knapsack problem.\n- Utilize bit manipulation to handle group constraints efficiently.",
    "code": "from typing import List\n\ndef max_knapsack_value_with_groups(weights: List[int], values: List[int], max_weight: int, groups: List[List[int]]) -> int:\n    n = len(weights)\n    num_combinations = 1 << len(groups)  # Total number of ways to include/exclude group combinations\n    dp = [-float('inf')] * (max_weight + 1)\n    dp[0] = 0\n    \n    for g in range(len(groups)):\n        w_sum, v_sum = 0, 0\n        indices = groups[g]\n        for idx in indices:\n            w_sum += weights[idx]\n            v_sum += values[idx]\n        \n        # Traverse backwards to avoid using the same group more than once per iteration\n        for current_weight in range(max_weight, -1, -1):\n            if dp[current_weight] >= 0 and current_weight + w_sum <= max_weight:\n                new_weight = current_weight + w_sum\n                dp[new_weight] = max(dp[new_weight], dp[current_weight] + v_sum)\n    \n    return max(dp)",
    "tests": [
        "assert max_knapsack_value_with_groups([2, 3, 4, 5], [3, 4, 5, 6], 5, [[0, 1], [2, 3]]) == 7",
        "assert max_knapsack_value_with_groups([1, 2, 3], [10, 15, 40], 6, []) == 55",
        "assert max_knapsack_value_with_groups([4, 5, 6], [10, 20, 30], 7, [[0, 1]]) == 20",
        "assert max_knapsack_value_with_groups([2, 3, 5], [8, 12, 18], 8, [[0, 2], [1]]) == 26"
    ],
    "difficulty": "insanely difficult",
    "model": "phi4:latest",
    "style": "Interview Query"
}