{
    "title": "Hard: Maximal Network Flow Problem",
    "description": "The problem involves designing a function that calculates the maximum flow in a network. A flow network is a directed graph with a source node (s), sink node (t), and edges with capacities. The goal is to find the maximum flow from s to t, subject to the constraint that the flow on each edge does not exceed its capacity.\n\n#### Function Signature\n```\ndef maximal_flow(graph: list[list[int]], source: int, sink: int) -> int:\n``` \n\n#### Input\n- `graph` (list of lists): A 2D list representing the graph, where `graph[i][j]` is the capacity of the edge from node `i` to node `j`. The graph has a source node `source` and sink node `sinking`, and all other nodes are regular nodes.\n- `source` (int): The index of the source node in the graph.\n- `sink` (int): The index of the sink node in the graph.\n\n#### Output\n- Returns the maximum flow from the source node to the sink node.",
    "code": "import collections\n\ndef maximal_flow(graph: list[list[int]], source: int, sink: int) -> int:\n    # Create residual graph\n    residual_graph = [list(row) for row in graph]\n    \n    max_flow = 0\n    \n    while True:\n        # Find augmenting path using BFS\n        queue = collections.deque([source])\n        parent = [-1] * len(graph)\n        \n        while queue and parent[sink] == -1:\n            node = queue.popleft()\n            \n            for neighbor, capacity in enumerate(residual_graph[node]):\n                if capacity > 0 and parent[neighbor] == -1:\n                    queue.append(neighbor)\n                    parent[neighbor] = node\n        \n        # If no augmenting path is found, stop\n        if not queue or parent[sink] == -1:\n            break\n        \n        # Find minimum residual capacity along the path\n        flow = float('inf')\n        current_node = sink\n        while current_node != source:\n            previous_node = parent[current_node]\n            flow = min(flow, residual_graph[previous_node][current_node])\n            current_node = previous_node\n        \n        # Update residual graph and max flow\n        current_node = sink\n        while current_node != source:\n            previous_node = parent[current_node]\n            residual_graph[previous_node][current_node] -= flow\n            residual_graph[current_node][previous_node] += flow\n            current_node = previous_node\n        \n        max_flow += flow\n    \n    return max_flow",
    "tests": [
        "assert maximal_flow([[0, 3, 0, 2], [1, 2, 1, 1], [0, 0, 0, 2], [0, 1, 3, 0]], 0, 3) == 4",
        "assert maximal_flow([[0, 5, 0, 1, 0], [1, 3, 2, 2, 0], [0, 0, 0, 4, 3], [0, 1, 0, 2, 0], [0, 2, 1, 1, 0]], 0, 4) == 7"
    ],
    "model": "llama3:latest-repaired by Llama 3"
}