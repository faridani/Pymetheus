{
    "title": "Hard - Maze Solver",
    "description": "You are given a maze represented as a 2D list of integers. The value 0 represents an empty cell, the value 1 represents a wall, and the values 2 represents the starting point and 3 represents the end point. Write a function `solve_maze` that takes the maze as input and returns True if there is a path from the start to the end point, False otherwise.\n\n#### Function Signature\n```python\ndef solve_maze(maze: list[list[int]]) -> bool:\n```\n\n#### Input\n- `maze` (list[list[int]]): A 2D list representing the maze.\n\n#### Output\n- Returns True if there is a path from the start to the end point, False otherwise.\nYou can use Depth First Search(DFS) or Breadth First Search(BFS) algorithms to solve this problem.",
    "code": "def solve_maze(maze: list[list[int]]) -> bool:\n    rows = len(maze)\n    cols = len(maze[0])\n\n    def is_valid(row, col):\n        return 0 <= row < rows and 0 <= col < cols and maze[row][col] != 1\n\n    def dfs(row, col):\n        if maze[row][col] == 3:\n            return True\n        maze[row][col] = 1 # Mark current cell as visited\n        for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            new_row = row + dr\n            new_col = col + dc\n            if is_valid(new_row, new_col) and dfs(new_row, new_col):\n                return True\n        return False\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 2:\n                return dfs(i, j)\n    return False",
    "tests": [
        "maze1 = [[0, 0, 1, 0, 0], [0, 0, 0, 1, 0], [2, 1, 0, 1, 3]]\nassert solve_maze(maze1) == True",
        "maze2 = [[0, 0, 1, 0, 0], [0, 1, 0, 1, 0], [2, 1, 1, 1, 3]]\nassert solve_maze(maze2) == False"
    ],
    "model": "gemma2:27b-repaired by Llama 3"
}