{
    "title": "Hard: Tree Diameter",
    "description": "Given a tree represented as an adjacency list, find the diameter of the tree. The diameter is the longest path between any two nodes in the tree.\n\n#### Function Signature\n```ndef tree_diameter(tree: dict) -> int:\n```\n\n#### Input\n- `tree` (dict): A dictionary representing the tree, where each key is a node and its corresponding value is a list of neighboring nodes.\n\n#### Output\n- Returns the diameter of the tree as an integer.\n\nExample:\nThe tree {0: [1], 1: [0, 2], 2: [1]} has diameter 2 (the longest path is between nodes 0 and 2).\nThe tree {0: [], 1: [0, 2], 2: [1]} has diameter 3 (the longest path is between nodes 0 and 2).",
    "code": "from collections import deque\n\ndef tree_diameter(tree: dict) -> int:\n    # Initialize the result\n    diameter = 0\n    \n    # Iterate over each node in the tree\n    for node in tree:\n        # Perform BFS to find the furthest node from this node\n        queue = deque([(node, 0)])\n        farthest_node = None\n        max_distance = 0\n        while queue:\n            current_node, distance = queue.popleft()\n            if distance > max_distance:\n                max_distance = distance\n                farthest_node = current_node\n            for neighbor in tree[current_node]:\n                queue.append((neighbor, distance + 1))\n        \n        # Update the diameter\n        diameter = max(diameter, max_distance)\n    \n    return diameter",
    "tests": [
        "assert tree_diameter({0: [], 1: [0], 2: [1]}) == 3",
        "assert tree_diameter({0: [1], 1: [0, 2], 2: [1]}) == 2",
        "assert tree_diameter({0: [1, 2], 1: [0, 2], 2: [0, 1]}) == 3"
    ],
    "model": "llama3:latest-repaired by Llama 3"
}