"Here's your insanely difficult python coding question:\n\n{\n\"title\": \"Hard: Finding the Shortest Path on a Graph\",\n\"description\": \"Given an undirected weighted graph represented as an adjacency matrix, write a function `shortest_path` that finds the shortest path between two nodes. The graph may contain negative weight edges.\\n\\n#### Function Signature\\n```python\\ndef shortest_path(graph: list[list[int]], start: int, end: int) -> tuple[float, list[int]]:\\n```\\n\\n#### Input\\n- `graph` (list[list[int]]): An adjacency matrix representing the graph. Each row and column represents a node, and the value at row `i` and column `j` is the weight of the edge between nodes `i` and `j`. If there is no edge between two nodes, the corresponding value in the matrix is 0.\\n- `start` (int): The index of the starting node.\\n- `end` (int): The index of the ending node.\\n\\n#### Output\\n- Returns a tuple containing the minimum total weight of the shortest path and a list of nodes representing the shortest path from the start node to the end node.\",\n\"code\": \"\"\"\nimport heapq\n\ndef shortest_path(graph, start, end):\n    # Initialize distances and previous nodes\n    distances = [float('inf')] * len(graph)\n    previous_nodes = [None] * len(graph)\n    distances[start] = 0\n\n    # Create a priority queue for Dijkstra's algorithm\n    queue = [(0, start)]\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        # If the current node is the end node, we've found the shortest path\n        if current_node == end:\n            break\n\n        # For each neighbor of the current node\n        for neighbor, weight in enumerate(graph[current_node]):\n            if weight > 0:  # No edge between nodes if weight is 0\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    previous_nodes[neighbor] = current_node\n                    heapq.heappush(queue, (distance, neighbor))\n\n    # Reconstruct the shortest path from start to end node\n    path = []\n    while end is not None:\n        path.append(end)\n        end = previous_nodes[end]\n    return distances[-1], list(reversed(path))\n\"\"\", \"tests\": [\n\"assert shortest_path([[0, 3, 7, 0], [3, 0, -2, 0], [7, -2, 0, -5], [0, 0, -5, 0]]) == (6.0, [1, 2, 3])\",\n\"assert shortest_path([[0, 4, 0, 0], [4, 0, -1, 0], [0, -1, 0, -2], [0, 0, -2, 0]]) == (5.0, [0, 1, 2])\",\n\"assert shortest_path([[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]) == (float('inf'), [])\"]\n}"