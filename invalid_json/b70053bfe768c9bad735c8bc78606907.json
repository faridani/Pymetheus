"Here is a challenging Python coding question:\n\n```\n{\n\"title\": \"Hard: Matrix to Tree\", \n\"description\": \"Given a matrix where each cell contains either 0 or the height of a building, write a function `matrix_to_tree` that constructs a tree structure from the matrix. The tree nodes should be ordered in such a way that a node's left child is its smallest neighbor (in all four directions: up, down, left, right), and if there are multiple neighbors with the same height, any of them can be chosen as the left child.\\n\\n#### Function Signature\\n```python\\ndef matrix_to_tree(matrix: list[list[int]]) -> list[dict]:\\n```\\n\\n#### Input\\n- `matrix` (list[list[int]]): A 2D list where each cell contains either 0 or a positive integer representing the height of a building.\\n\\n#### Output\\n- Returns a list of dictionaries, where each dictionary represents a node in the tree structure. Each node has three keys: 'height' (the value stored in the corresponding matrix cell), 'left' (a reference to the left child node), and 'right' (a reference to the right child node).\\n\", \n\"code\": \"import heapq\n\ndef matrix_to_tree(matrix):\n    # Create a priority queue to store nodes\n    nodes = []\n\n    for i, row in enumerate(matrix):\n        for j, height in enumerate(row):\n            if height > 0:\n                nodes.append({'height': height, 'pos': (i, j)})\n\n    heapq.heapify(nodes)\n\n    root = {'height': None, 'left': None, 'right': None}\n\n    while nodes:\n        # Extract the node with the smallest neighbor\n        node = heapq.heappop(nodes)\n        pos = node['pos']\n\n        if pos[0] > 0 and matrix[pos[0]-1][pos[1]] > 0:\n            left_node = {'height': matrix[pos[0]-1][pos[1]], 'left': None, 'right': None}\n            nodes.append(left_node)\n            heapq.heapify(nodes)\n\n        if pos[0] < len(matrix) - 1 and matrix[pos[0]+1][pos[1]] > 0:\n            right_node = {'height': matrix[pos[0]+1][pos[1]], 'left': None, 'right': None}\n            nodes.append(right_node)\n            heapq.heapify(nodes)\n\n        if pos[1] > 0 and matrix[pos[0]][pos[1]-1] > 0:\n            left_up_node = {'height': matrix[pos[0]][pos[1]-1], 'left': None, 'right': None}\n            nodes.append(left_up_node)\n            heapq.heapify(nodes)\n\n        if pos[1] < len(matrix[0]) - 1 and matrix[pos[0]][pos[1]+1] > 0:\n            right_down_node = {'height': matrix[pos[0]][pos[1]+1], 'left': None, 'right': None}\n            nodes.append(right_down_node)\n            heapq.heapify(nodes)\n\n        node['left'] = left_node if left_node else None\n        node['right'] = right_node if right_node else None\n\n    return [root]\n\n\", \n\"tests\": [\"assert len(matrix_to_tree([[0, 5], [3, 2]])) == 1\", \"assert len(matrix_to_tree([[0, 5, 4], [3, 2, 1], [0, 0, 0]])) == 3\", \"assert len(matrix_to_tree([[0, 0, 8, 7], [6, 9, 2, 3], [0, 4, 5, 1]])) == 4\"]}"