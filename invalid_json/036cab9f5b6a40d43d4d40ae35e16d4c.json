"Here's your new Python coding question:\n\n{\"title\": \"Hard: Finding the Shortest Path\", \"description\": \"Given a graph represented as an adjacency list, and two nodes u and v, find the shortest path from node u to node v. The graph may contain negative weight edges.\\n\\n#### Function Signature\\n```python\\ndef shortest_path(graph, start, end) -> int:\\n```\\n\\n#### Input\\n- `graph` (dict): A dictionary representing an adjacency list where each key is a node and the corresponding value is another dictionary that maps neighboring nodes to their weights.\\n- `start` (int): The starting node.\\n- `end` (int): The ending node.\\n\\n#### Output\\n- Returns the length of the shortest path from the start node to the end node. If there's no path, return -1.\", \"code\": \"import heapq\\ndef shortest_path(graph, start, end):\\n    queue = [(0, start)]\\n    distances = {node: float('inf') for node in graph}\\n    distances[start] = 0\\n    while queue:\\n        distance, node = heapq.heappop(queue)\\n        if distance > distances[node]:\\n            continue\\n        for neighbor, weight in graph[node].items():\\n            old_distance = distances[neighbor]\\n            new_distance = distance + weight\\n            if new_distance < old_distance:\\n                distances[neighbor] = new_distance\\n                heapq.heappush(queue, (new_distance, neighbor))\\n    return distances.get(end, -1)\", \"tests\": [\"assert shortest_path({'A': {B: 3, C: -2}, B: {C: 2}, C: {}}, 'A', 'C') == 4\", \"assert shortest_path({'A': {B: 3, C: -2}, B: {C: 2}, C: {}}, 'A', 'D') == -1\", \"assert shortest_path({'A': {B: 3, C: -2}, B: {C: 2}, C: {C: 5}}, 'A', 'C') == 3\"]}"