"Here's a new question that meets your requirements:\n\n```json\n{\n  \"title\": \"Minimum Window Substring (Medium)\",\n  \"description\": \"Given two strings `s` and `t`, find the minimum window of `s` that contains all characters of `t`.\n\nThe `find_min_window` function should return the smallest substring of `s` that includes all characters of `t`. If no such window exists, it should return an empty string.\n\nNote that the order of characters in the window does not matter.\\n\\n#### Function Signature\\n```python\\ndef find_min_window(s: str, t: str) -> str:\\n```\n\n#### Input\n- `s` (str): A string containing all characters of `t`.\n- `t` (str): A string containing unique characters.\n\n#### Output\n- Returns the minimum window of `s` that contains all characters of `t`, or an empty string if no such window exists.\n\",\n  \"code\": \"\nfrom collections import defaultdict\n\ndef find_min_window(s: str, t: str) -> str:\n    # Base case: If string s is shorter than string t, return empty string\n    if len(s) < len(t):\n        return ''\n\n    # Create a dictionary to store the frequency of characters in string t\n    t_freq = defaultdict(int)\n    for char in t:\n        t_freq[char] += 1\n\n    # Initialize variables to track the minimum window\n    min_window = ''\n    min_len = float('inf')\n\n    # Initialize variables to track the current window\n    left = 0\n    formed = 0\n\n    # Create a dictionary to store the frequency of characters in the current window\n    window_freq = defaultdict(int)\n\n    # Iterate over string s\n    for right in range(len(s)):\n        # Add the character at the right end of the window to the window frequency dictionary\n        char = s[right]\n        window_freq[char] += 1\n\n        # If the character is in t and its frequency in the window is equal to its frequency in t, increment formed\n        if char in t_freq and window_freq[char] == t_freq[char]:\n            formed += 1\n\n        # While the window contains all characters of t and the left end of the window is not at the beginning of s\n        while left <= right and formed == len(t_freq):\n            # Update the minimum window if it's smaller than the current minimum window\n            if right - left + 1 < min_len:\n                min_window = s[left:right + 1]\n                min_len = right - left + 1\n\n            # Remove the character at the left end of the window from the window frequency dictionary\n            char = s[left]\n            window_freq[char] -= 1\n\n            # If the character is in t and its frequency in the window is less than its frequency in t, decrement formed\n            if char in t_freq and window_freq[char] < t_freq[char]:\n                formed -= 1\n\n            # Move the left end of the window to the right\n            left += 1\n\n    return min_window\",\n  \"tests\": [\n    \"assert find_min_window('ADOBECODEBANJDOFJ', 'ABC') == 'BCA'\",\n    \"assert find_min_window('a\", \"assert find_min_window('', '') == ''\"]\n}\n```\n\nThis function uses the sliding window technique to find the minimum window of `s` that contains all characters of `t`. It maintains two dictionaries, `t_freq` and `window_freq`, to track the frequency of characters in strings `t` and the current window, respectively. The function iterates over string `s` and updates the window frequency dictionary accordingly. When the window contains all characters of `t`, it checks if the current window is smaller than the minimum window found so far and updates the minimum window if necessary. Finally, it returns the minimum window or an empty string if no such window exists."