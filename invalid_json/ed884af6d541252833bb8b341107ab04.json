"Here's your requested Python coding question:\n\n{\n    \"title\": \"Hardest Maze Problem Ever (Hard)\",\n    \"description\": \"A maze is a grid with rows and columns of cells, where some cells are blocked and others are not. You're given the size of the maze, the blocked cells, and the start and end positions. Write a function that navigates from the start position to the end position in the fewest possible moves.\\n\\n#### Function Signature\\n```python\\ndef shortest_path(maze_size: tuple, blocked_cells: list, start: tuple, end: tuple) -> int:\\n```\\n\\n#### Input\\n- `maze_size` (tuple): The size of the maze as a tuple of two integers, representing the number of rows and columns.\\n- `blocked_cells` (list): A list of tuples, each containing the row and column indices of a blocked cell in the maze.\\n- `start` (tuple): The start position as a tuple of two integers, representing the row and column indices.\\n- `end` (tuple): The end position as a tuple of two integers, representing the row and column indices.\\n\\n#### Output\\n- Returns the length of the shortest path from the start to the end position. If there is no possible path, return -1.\\n\",\n    \"code\": \"\"\"\nimport heapq\n\ndef shortest_path(maze_size: tuple, blocked_cells: list, start: tuple, end: tuple) -> int:\n    # Create a grid with all cells unvisited\n    maze = [[False] * maze_size[1] for _ in range(maze_size[0])]\n    \n    # Mark the blocked cells as visited\n    for cell in blocked_cells:\n        maze[cell[0]][cell[1]] = True\n    \n    # Initialize the distance to the start position as 0 and all other cells as infinity\n    distances = [[float('inf')] * maze_size[1] for _ in range(maze_size[0])]\n    distances[start[0]][start[1]] = 0\n    \n    # Create a priority queue with the start position\n    pq = [(0, start)]\n    \n    while pq:\n        (dist, cell) = heapq.heappop(pq)\n        \n        if dist > distances[cell[0]][cell[1]]:\n            continue\n        \n        for neighbor in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            row, col = cell[0] + neighbor[0], cell[1] + neighbor[1]\n            \n            if row < 0 or row >= maze_size[0] or col < 0 or col >= maze_size[1]:\n                continue\n            \n            if maze[row][col] or distances[row][col] <= dist:\n                continue\n            \n            distances[row][col] = dist + 1\n            heapq.heappush(pq, (distances[row][col], (row, col)))\n    \n    # Return the distance to the end position if it's reachable, -1 otherwise\n    return distances[end[0]][end[1]] if distances[end[0]][end[1]] != float('inf') else -1\n\"\"\",\n    \"tests\": [\n        \"assert shortest_path((4, 5), [(1, 2), (3, 4)], (0, 0), (3, 2)) == 7\",\n        \"assert shortest_path((2, 2), [(1, 1)], (0, 0), (1, 1)) == -1\",\n        \"assert shortest_path((5, 5), [], (0, 0), (4, 4)) == 5\"\n    ]\n}"