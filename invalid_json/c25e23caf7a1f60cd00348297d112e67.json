"```json\n{\n  \"title\": \"Easy: Minimum Window Substring\",\n  \"description\": \"Given two strings `s` and `t`, find the minimum window of characters in `s` that contains all characters of `t`. If there is no such window, return an empty string. Note that if there are multiple such windows, you should return the one with the maximum start position or if there is a tie, return the one with the most frequent occurrence of the character at the start position.\\n\\n#### Function Signature\\n```python\\ndef min_window(s: str, t: str) -> str:\\n```\\n\\n#### Input\\n- `s` (str): The string that may contain all characters of `t`.\\\\n- `t` (str): The string for which we need to find a minimum window in `s`.\\\\n\\n#### Output\\n- Returns the minimum window of characters in `s` that contains all characters of `t`, or an empty string if no such window exists.\",\n  \"code\": \"\"\"\nfrom collections import Counter\n\ndef min_window(s: str, t: str) -> str:\n    # Count the frequency of each character in t\n    t_count = Counter(t)\n    \n    # Calculate the total number of characters needed to match t\n    required_chars = len(t_count)\n    \n    # Initialize the minimum window and its length\n    min_window = \"\"\n    min_len = float('inf')\n    \n    # Initialize the left and right pointers for the sliding window\n    left = 0\n    \n    # Initialize the formed character count\n    formed = 0\n    \n    # Create a dictionary to store the frequency of each character in the current window\n    window_counts = {}\n    \n    # Iterate over the string s\n    for right in range(len(s)):\n        # Add the current character to the window counts\n        char = s[right]\n        if char in t_count:\n            window_counts[char] = window_counts.get(char, 0) + 1\n            \n            # If the frequency of the current character is equal to its count in t,\n            # increment the formed character count\n            if window_counts[char] == t_count[char]:\n                formed += 1\n    \n        # While the window contains all characters of t and the left pointer is not at the start of the string\n        while left <= right and formed == required_chars:\n            # Update the minimum window if it is smaller than the current window\n            if right - left + 1 < min_len:\n                min_window = s[left:right + 1]\n                min_len = right - left + 1\n            \n            # Remove the character at the left pointer from the window counts\n            char = s[left]\n            if char in t_count:\n                window_counts[char] -= 1\n                \n                # If the frequency of the current character is less than its count in t,\n                # decrement the formed character count\n                if window_counts[char] < t_count[char]:\n                    formed -= 1\n            \n            # Move the left pointer to the right\n            left += 1\n    \n    return min_window\n\"\"\",\n  \"tests\": [\n    \"assert min_window('ADOEI', 'OIE' ) == 'OIE'\",\n    \"assert min_window('a a a a\", \"assert min_window('', '') =='\",\n    \"assert min_window('', 'abc') == ''\"\n  ]\n}\n```"