"Here's an insanely difficult coding question for you. This problem involves implementing a function to find the shortest path in a grid with obstacles, using Dijkstra's algorithm with a twist.\n\n```json\n{\n  \"title\": \"Shortest Path in Grid with Obstacles (Hard)\",\n  \"description\": \"Given a grid of size n x m filled with 0s and 1s where 0 represents traversable cells and 1 represents obstacles. Find the shortest path from top-left to bottom-right cell, considering that you can only move right or down, and you can cross an obstacle by paying a cost of `cost`. The function should take three arguments: `grid` (a list of lists representing the grid), `cost` (the cost to cross an obstacle), and `start` and `end` tuples representing the start and end positions.\\n\\n#### Function Signature\\n```python\\ndef shortest_path(grid: List[List[int]], cost: int, start: Tuple[int, int], end: Tuple[int, int]) -> Optional[int]:\\n```\\n\\n#### Input\\n- `grid`: A list of lists containing integers 0 and 1.\\n- `cost`: The cost to cross an obstacle (integer).\\n- `start`: A tuple `(i, j)` representing the starting position in the grid.\\n- `end`: A tuple `(i, j)` representing the ending position in the grid.\\n\\n#### Output\\n- Returns the length of the shortest path as an integer if a valid path exists. If there's no valid path or start/end positions are invalid, return None.\\n\",\n  \"code\": \"from typing import List, Tuple, Optional\\nimport heapq\\n\\ndef shortest_path(grid: List[List[int]], cost: int, start: Tuple[int, int], end: Tuple[int, int]) -> Optional[int]:\\n    n, m = len(grid), len(grid[0])\\n    if not (0 <= start[0] < n and 0 <= start[1] < m) or not (0 <= end[0] < n and 0 <= end[1] < m):\\n        return None\\n    heap = [(grid[start[0]][start[1]], start)]\\n    distances = {(i, j): float('inf') for i in range(n) for j in range(m)}\\ndistances[start] = grid[start[0]][start[1]]\\n    directions = [(0, 1), (1, 0)]\\n    while heap:\\n        d, (i, j) = heapq.heappop(heap)\\n        if i == end[0] and j == end[1]:\\n            return d\\n        for di, dj in directions:\\n            ni, nj = i + di, j + dj\\n            if 0 <= ni < n and 0 <= nj < m:\\n                new_distance = distances[(i, j)] + grid[ni][nj]\\n                if obstacle := grid[ni][nj], obstacle == 1:\\n                    new_distance += cost\\n                if new_distance < distances.get((ni, nj), float('inf')):\\n                    distances[(ni, nj)] = new_distance\\n                    heapq.heappush(heap, (new_distance, (ni, nj)))\\n    return None\",\n  \"tests\": [\n    \"assert shortest_path([[0, 1], [1, 0]], cost=2, start=(0, 0), end=(1, 1)) == 4\",\n    \"assert shortest_path([[0, 0, 1], [1, 0, 0], [0, 0, 0]], cost=3, start=(0, 0), end=(2, 2)) == 5\",\n    \"assert shortest_path([[1, 0, 1], [0, 1, 0], [1, 0, 1]], cost=4, start=(0, 0), end=(2, 2)) is None\",\n    \"assert shortest_path([[0, 1], [1, 0]], cost=5, start=(0, 0), end=(1, 1)) == float('inf')\"\n  ]\n}\n```"