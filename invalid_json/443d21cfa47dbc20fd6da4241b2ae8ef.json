"<think>\nAlright, I need to create a super hard Python coding question based on the user's request. Let me see what they provided as an example and their specific instructions.\n\nThe user wants a new problem, not just a palindrome checker. They mentioned it should be hard, so I need something challenging. The template includes title, description with function signature, input/output details, constraints, hints, code, and tests in JSON format. Also, the output must be strictly in JSON without any extra text or markdown.\n\nHmm, what's a good hard problem? Maybe something involving permutations but avoiding duplicates efficiently. Oh, \"Unique Permutations of a Multiset\" could work. It's a classic problem that requires handling duplicates without generating all possibilities first, which is more efficient.\n\nLet me outline the problem: Given a multiset (a list with possible duplicate elements), return all unique permutations as a list of lists. The challenge is to do this efficiently, especially for larger inputs or those with many duplicates.\n\nFor constraints, I'll set that each element can be an integer between 0 and 9, but it's flexible. This helps in testing without being too restrictive.\n\nThe function signature should take a list of integers and return a list of lists of integers. The description needs to explain the problem clearly, including examples. For instance, input [1,1,2] should output [[1,1,2], [1,2,1], [2,1,1]].\n\nIn terms of approach, backtracking with pruning is ideal. We can sort the elements and then swap only when necessary to avoid duplicates. This involves checking if a number has been used at the current position before proceeding.\n\nNow, for the code: I'll write a function that uses recursion. It will keep track of used indices to prevent reuse. Also, sorting helps in grouping duplicates together so we can skip over them easily. The base case is when all elements are used, adding the permutation to the result.\n\nTesting is crucial. I'll include various test cases like empty list, single element, two identical elements, and more complex ones with multiple duplicates.\n\nPutting it all into JSON: Title, description with details, code implementing the function, and tests as assert statements. Make sure everything is properly formatted without any markdown or extra text.\n\nFinally, ensuring the JSON structure is correct with proper escaping for newlines and quotes. The code section should have the full functioning Python code, and tests are a list of strings each being an assertion.\n</think>\n\n```json\n{\n    \"title\": \"Unique Permutations of a Multiset (Hard)\",\n    \"description\": \"Given a multiset of integers, return all unique permutations in any order. A permutation is a rearrangement of the entire set of numbers. Two permutations are considered the same if they have the same elements in the same order.\\n\\n#### Function Signature\\n```python\\ndef unique_permutations(nums: List[int]) -> List[List[int]]:\\n```\\n\\n#### Input\\n- `nums` (List[int]): A list containing integers which may contain duplicates. Each integer can be between 0 and 9 inclusive, but this range is not strictly enforced.\\n\\n#### Output\\n- Returns a list of lists where each sublist represents a unique permutation of the input list.\\n\\n#### Constraints\\n- The length of `nums` can be up to 10 elements.\n- Each integer in `nums` can appear multiple times (e.g., [2,2,3,3]).\n- The solution should efficiently handle cases with many duplicates without generating duplicate permutations in the first place.\\n\",\n    \"code\": \"from typing import List\\n\\n\\ndef unique_permutations(nums: List[int]) -> List[List[int]]:\\n    result = []\\n    nums.sort()\\n    used = [False] * len(nums)\\n    \\n    def backtrack(current_path, used):\\n        if len(current_path) == len(nums):\\n            result.append(list(current_path))\\n            return\\n        for i in range(len(nums)):\\n            if not used[i]:\\n                if i > 0 and nums[i] == nums[i-1] and not used[i-1]:\\n                    continue\\n                used[i] = True\\n                current_path.append(nums[i])\\n                backtrack(current_path, used)\\n                used[i] = False\\n                current_path.pop()\\n    \\n    backtrack([], used)\\n    return result\",\n    \"tests\": [\n        \"assert unique_permutations([1, 1, 2]) == [[1, 1, 2], [1, 2, 1], [2, 1, 1]]\",\n        \"assert len(unique_permutations([3, 3, 3])) == 1\",\n        \"assert unique_permutations([]) == [[]]\",\n        \"assert unique_permutations([0]) == [[0]]\",\n        \"assert unique_permutations([4, 4, 5, 6]) == [[4,4,5,6], [4,4,6,5], [4,5,4,6], [4,5,6,4], [4,6,4,5], [4,6,5,4], [5,4,4,6], [5,4,6,4], [5,6,4,4], [6,4,4,5], [6,4,5,4], [6,5,4,4]]\"\n    ]\n}\n```"